

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="CoachHe">
  <meta name="keywords" content="">
  
    <meta name="description" content="字符串常量池要了解字符串常量池我们需要先知道运行时常量池，这里会在 [[2.3.2 虚拟机栈]]中进行详细介绍，这里我们就不展开了，主要来看字符串常量池。 字符串常量池中的内容是在类加载完成，经过验证、准备阶段之后存放在字符串常量池中。 字符串常量池存储位置的演进  可以看到，字符串常量池原本是属于运行时常量池的一部分，从 jdk7 开始被分割开来，分配到了堆空间中。 字符串常量池中存放的内容这里">
<meta property="og:type" content="article">
<meta property="og:title" content="补充-String和字符串常量池">
<meta property="og:url" content="http://example.com/2022/12/48259411da1e.html">
<meta property="og:site_name" content="CoachHe&#39;s Blog">
<meta property="og:description" content="字符串常量池要了解字符串常量池我们需要先知道运行时常量池，这里会在 [[2.3.2 虚拟机栈]]中进行详细介绍，这里我们就不展开了，主要来看字符串常量池。 字符串常量池中的内容是在类加载完成，经过验证、准备阶段之后存放在字符串常量池中。 字符串常量池存储位置的演进  可以看到，字符串常量池原本是属于运行时常量池的一部分，从 jdk7 开始被分割开来，分配到了堆空间中。 字符串常量池中存放的内容这里">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221218041521.png">
<meta property="og:image" content="https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221215024246.png">
<meta property="og:image" content="https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221215130047.png">
<meta property="og:image" content="https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221216003637.png">
<meta property="og:image" content="https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221216004129.png">
<meta property="article:published_time" content="2022-12-17T19:31:59.000Z">
<meta property="article:modified_time" content="2023-01-09T17:19:27.308Z">
<meta property="article:author" content="CoachHe">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221218041521.png">
  
  
  
  <title>补充-String和字符串常量池 - CoachHe&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Fluid</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="补充-String和字符串常量池"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-12-18 03:31" pubdate>
          2022年12月18日 凌晨
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          14k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          117 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">补充-String和字符串常量池</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h1><p>要了解字符串常量池我们需要先知道运行时常量池，这里会在 [[2.3.2 虚拟机栈]]中进行详细介绍，这里我们就不展开了，主要来看字符串常量池。</p>
<p>字符串常量池中的内容是在类加载完成，经过验证、准备阶段之后存放在字符串常量池中。</p>
<h2 id="字符串常量池存储位置的演进"><a href="#字符串常量池存储位置的演进" class="headerlink" title="字符串常量池存储位置的演进"></a>字符串常量池存储位置的演进</h2><img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221218041521.png" srcset="/img/loading.gif" lazyload width = "50%" />

<p>可以看到，字符串常量池原本是属于运行时常量池的一部分，从 jdk7 开始被分割开来，分配到了堆空间中。</p>
<h2 id="字符串常量池中存放的内容"><a href="#字符串常量池中存放的内容" class="headerlink" title="字符串常量池中存放的内容"></a>字符串常量池中存放的内容</h2><p>这里其实是有比较大的争议的，有些人认为例如 <code>ab</code> 之类的字符串对象会创建在堆中，而字符串常量池只存一个引用，实际对象还是在堆中，例如：<a target="_blank" rel="noopener" href="https://xie.infoq.cn/article/45250864e429630990703f7f3">从字符串到常量池，一文看懂String类设计</a></p>
<p>这篇文章所持有的观点就是字符串常量池只存堆中对象的引用。</p>
<p>很遗憾，这里我持有的观点和这篇文章是不同的，我认为，<strong>字符串常量池中存放的就是实际的 String 对象</strong>。</p>
<p>当然我是有证据的，具体的可以来看下 String 的 <code>intern()</code> 方法里面的定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns a canonical representation for the string object.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * A pool of strings, initially empty, is maintained privately by the</span><br><span class="hljs-comment"> * class &#123;<span class="hljs-doctag">@code</span> String&#125;.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * When the intern method is invoked, if the pool already contains a</span><br><span class="hljs-comment"> * string equal to this &#123;<span class="hljs-doctag">@code</span> String&#125; object as determined by</span><br><span class="hljs-comment"> * the &#123;<span class="hljs-doctag">@link</span> #equals(Object)&#125; method, then the string from the pool is</span><br><span class="hljs-comment"> * returned. Otherwise, this &#123;<span class="hljs-doctag">@code</span> String&#125; object is added to the</span><br><span class="hljs-comment"> * pool and a reference to this &#123;<span class="hljs-doctag">@code</span> String&#125; object is returned.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * It follows that for any two strings &#123;<span class="hljs-doctag">@code</span> s&#125; and &#123;<span class="hljs-doctag">@code</span> t&#125;,</span><br><span class="hljs-comment"> * &#123;<span class="hljs-doctag">@code</span> s.intern() == t.intern()&#125; is &#123;<span class="hljs-doctag">@code</span> true&#125;</span><br><span class="hljs-comment"> * if and only if &#123;<span class="hljs-doctag">@code</span> s.equals(t)&#125; is &#123;<span class="hljs-doctag">@code</span> true&#125;.</span><br><span class="hljs-comment"> * &lt;p&gt;</span><br><span class="hljs-comment"> * All literal strings and string-valued constant expressions are</span><br><span class="hljs-comment"> * interned. String literals are defined in section 3.10.5 of the</span><br><span class="hljs-comment"> * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span>  a string that has the same contents as this string, but is</span><br><span class="hljs-comment"> *          guaranteed to be from a pool of unique strings.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@jls</span> 3.10.5 String Literals</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> String <span class="hljs-title function_">intern</span><span class="hljs-params">()</span>;<br></code></pre></td></tr></table></figure>

<p>我们来挑选其中最重要的几句话来看看（其余的会在本章接下来介绍 intern 方法的时候具体展开）</p>
<ul>
<li><p>A pool of strings, initially empty, is maintained privately by the class {@code String}.</p>
<p>  这句话意思是字符串常量池是由 String 类私有的一个最开始为空的数据结构。</p>
<p>  在这句话中我们可以了解到，这个字符串常量池是 String 类私有的，并且应该是全局唯一的，因此所有类共用这个字符串常量池，但是每个 class 都有一个运行时常量池，因此运行时常量池的数量应该比字符串常量池更多。</p>
</li>
<li><p>When the intern method is invoked, if the pool already contains a string equal to this {@code String} object as determined by the {@link # equals (Object)} method, then the string from the pool is returned. Otherwise, this  string object is added to the pool and a reference to this {@code String} object is returned.</p>
<p>  这句话的意思是当调用 <code>intern()</code> 方法时，如果运行时常量池中已经有了一个相等（equals）的字符串常量，那么直接返回这个 string 的引用。否则，这个 <strong>string 对象 (this string object)</strong> 会被加到字符串常量池中，并且返回引用。</p>
<p>  看到了吧，这个 <strong>string 对象</strong>！会被加载到字符串常量池中，而不是这个对象的引用会被加载到字符串常量池中，因此<strong>字符串常量池放的是实际的对应而不是引用</strong>！</p>
</li>
</ul>
<h1 id="定义-String-的方式"><a href="#定义-String-的方式" class="headerlink" title="定义 String 的方式"></a>定义 String 的方式</h1><p>定义 String 有两种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-type">String</span> <span class="hljs-variable">str_new</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;def&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这两种定义有什么区别呢？我们可以通过字节码来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> ldc #<span class="hljs-number">4</span> &lt;abc&gt;<br> <span class="hljs-number">2</span> astore_1<br> <span class="hljs-number">3</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">5</span> &lt;java/lang/String&gt;<br> <span class="hljs-number">6</span> dup<br> <span class="hljs-number">7</span> ldc #<span class="hljs-number">6</span> &lt;def&gt;<br> <span class="hljs-number">9</span> invokespecial #<span class="hljs-number">7</span> &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;<br><span class="hljs-number">12</span> astore_2<br><span class="hljs-number">13</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<h2 id="String-str-quot-abc-quot-对应的操作"><a href="#String-str-quot-abc-quot-对应的操作" class="headerlink" title="String str = &quot;abc&quot; 对应的操作"></a><code>String str = &quot;abc&quot;</code> 对应的操作</h2><p>序号和字节码中的序号保持一致</p>
<ol start="0">
<li>使用 <code>ldc</code> 将常量池中字符串 <code>abc</code> 的引用放入操作数栈中，注意，在这里 <code>ldc</code> 会触发对其符号引用的解析操作，具体可以看 [[7.3 类加载的过程]]，这里会创建一个字符串 <code>abc</code> 对应的对象并将其放入字符串常量池中。</li>
<li>将操作数栈顶的元素（也就是 <code>abc</code>）放入局部变量表的第一个位置（第 0 个是 this）。</li>
</ol>
<p>至此，<code>String str = &quot;abc&quot;</code> 已经结束，<code>str</code> 是一个引用，指向栈中的字符串 <code>abc</code></p>
<h2 id="String-str-new-String-quot-def-quot-对应的操作"><a href="#String-str-new-String-quot-def-quot-对应的操作" class="headerlink" title="String str = new String(&quot;def&quot;) 对应的操作"></a><code>String str = new String(&quot;def&quot;)</code> 对应的操作</h2><p>同样，序号和字节码中的序号保持一致</p>
<ol start="3">
<li>创建了一个 String 对象，保留了一个引用，结果为：def</li>
<li>将这个引用复制一份，也就是保留了两个引用，结果为：def, def</li>
<li>和第 0 行类似，使用 <code>ldc</code> 将常量池中指定的常量 <code>def</code> 放入操作数栈中</li>
<li>使用栈顶元素（也就是 <code>def</code>）参与构造器方法的的初始化，这样消耗了栈顶的 <code>def</code> 和 <code>dup</code> 得到的引用，值保留一个引用，指向的是堆中的对象。</li>
<li>将这个指向堆中对象的引用放入局部变量表的第二个位置。</li>
</ol>
<p>可以看到，两种不同方式创建得到的引用虽然表面上看是很像的，但实际上确实存在了很大的差别。最重要的就是第一个引用指向的是栈，第二个引用指向的是堆</p>
<h1 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h1><p>所谓字符串拼接就是两个字符串或者字符串和对象相加</p>
<p>在进行之前我们先了解一下拼接的规则：</p>
<h2 id="拼接的规则"><a href="#拼接的规则" class="headerlink" title="拼接的规则"></a>拼接的规则</h2><ol>
<li>常量和常量的拼接结果在常量池，原理是编译器优化</li>
<li>常量池中不会存在相同内容的变量</li>
<li><strong>只要其中有一个是变量，结果就在堆中</strong>。变量拼接的原理是 <code>StringBuilder</code></li>
<li>如果拼接的结果调用 <code>intern()</code> 方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址</li>
</ol>
<p>让我们慢慢来看，首先是上面第一条 : 常量和常量的拼接结果在常量池</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 证明常量拼接之后会通过编译器间优化放入常量池中</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ConcatenationTest1</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">a</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span>;<br>    <span class="hljs-type">String</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最终，java编译成.class，再执行.class</span><br><span class="hljs-comment">     * String a = &quot;abc&quot;;</span><br><span class="hljs-comment">     * String b = &quot;abc&quot;;</span><br><span class="hljs-comment">     */</span><br>    System.out.println(a == b); <span class="hljs-comment">//true</span><br>    System.out.println(a.equals(b)); <span class="hljs-comment">//true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，判断 <code>a == b</code> 时输出的是 <code>true</code>，这是因为在编译期进行优化，可以看下编译之后的 class 文件反编译的结果：</p>
<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221215024246.png" srcset="/img/loading.gif" lazyload width = "70%" />

<p>可以看到，编译期间进行了优化。</p>
<p>再看看第 3 条：<strong>只要其中有一个是变量，结果就在堆中</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 证明拼接时只要有一个变量，结果就会放入堆中  </span><br><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ConcatenationTest2</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEE&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hadoop&quot;</span>;  <br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEEhadoop&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEE&quot;</span> + <span class="hljs-string">&quot;hadoop&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s5</span> <span class="hljs-operator">=</span> s1 + <span class="hljs-string">&quot;hadoop&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s6</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;javaEE&quot;</span> + s2;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s7</span> <span class="hljs-operator">=</span> s1 + s2;  <br>  <br>    System.out.println(s3 == s4); <span class="hljs-comment">// true  </span><br>    System.out.println(s3 == s5); <span class="hljs-comment">// false  </span><br>    System.out.println(s3 == s6); <span class="hljs-comment">// false  </span><br>    System.out.println(s3 == s7); <span class="hljs-comment">// false  </span><br>    System.out.println(s5 == s6); <span class="hljs-comment">// false  </span><br>    System.out.println(s5 == s7); <span class="hljs-comment">// false  </span><br>    System.out.println(s6 == s7); <span class="hljs-comment">// false  </span><br>  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s8</span> <span class="hljs-operator">=</span> s6.intern();  <br>    System.out.println(s3 == s8); <span class="hljs-comment">// true  </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，只要里面有个变量存在，这里都是会 new 一个对象，那么结果就不可能相同了。</p>
<p>但是最后调用 <code>intern</code> 方法之后，会将其放入字符串常量池，那么此时 <code>s3</code> 和 <code>s8</code> 就指向同一个对象了。</p>
<p>那么原理是 <code>StringBuilder</code> 怎么理解呢？</p>
<p>来看看下面这段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> CoachHe  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/12/15 02:37  </span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Concatenation</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">mango</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mango&quot;</span>;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;abc&quot;</span> + mango + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-number">47</span>;  <br>        System.out.println(s);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>将其进行反汇编：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> ldc #<span class="hljs-number">14</span> &lt;mango&gt;<br> <span class="hljs-number">2</span> astore_1<br> <span class="hljs-number">3</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder&gt;<br> <span class="hljs-number">6</span> dup<br> <span class="hljs-number">7</span> invokespecial #<span class="hljs-number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;<br><span class="hljs-number">10</span> ldc #<span class="hljs-number">2</span> &lt;abc&gt;<br><span class="hljs-number">12</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">15</span> aload_1<br><span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">19</span> ldc #<span class="hljs-number">15</span> &lt;def&gt;<br><span class="hljs-number">21</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">24</span> bipush <span class="hljs-number">47</span><br><span class="hljs-number">26</span> invokevirtual #<span class="hljs-number">16</span> &lt;java/lang/StringBuilder.append : (I)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">29</span> invokevirtual #<span class="hljs-number">12</span> &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt;<br><span class="hljs-number">32</span> astore_2<br><span class="hljs-number">33</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<br><span class="hljs-number">36</span> aload_2<br><span class="hljs-number">37</span> invokevirtual #<span class="hljs-number">17</span> &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;<br><span class="hljs-number">40</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<p>进行分析，我们可以看到，首先从字符串常量池的第 14 个位置获取字符串常量 <code>mango</code> ，并将其放入本地变量表的第一个位置，注意，这里第 0 个位置是默认的输入参数 <code>args</code>，因为是静态方法所以没有 <code>this</code> 变量，具体的可以看 JVM 内容 [[8.2.2 局部变量表]]。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">0</span> ldc #<span class="hljs-number">14</span> &lt;mango&gt;<br><span class="hljs-number">2</span> astore_1<br></code></pre></td></tr></table></figure>

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221215130047.png" srcset="/img/loading.gif" lazyload width = "50%" />

<p>然后 new 了一个 <code>StringBuilder</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">3</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder&gt;<br><span class="hljs-number">6</span> dup<br><span class="hljs-number">7</span> invokespecial #<span class="hljs-number">10</span> &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;<br></code></pre></td></tr></table></figure>

<p>具体细节可以看 [[7.3 类加载的过程]]</p>
<p>接着会从局部变量表中位置为 1 的方法加载进来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">15</span> aload_1<br></code></pre></td></tr></table></figure>

<p>然后调用 <code>StringBuilder</code> 的 <code>append</code> 方法，将栈帧顶部的局部变量表中的字符串 <code>mongo</code> append 进这个 <code>StringBuilder</code> 中，接着步骤也是相同的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">19</span> ldc #<span class="hljs-number">15</span> &lt;def&gt;<br><span class="hljs-number">21</span> invokevirtual #<span class="hljs-number">11</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">24</span> bipush <span class="hljs-number">47</span><br><span class="hljs-number">26</span> invokevirtual #<span class="hljs-number">16</span> &lt;java/lang/StringBuilder.append : (I)Ljava/lang/StringBuilder;&gt;<br></code></pre></td></tr></table></figure>

<p>最后调用 <code>StringBuilder</code> 的 <code>toString</code> 方法，返回一个 <code>String</code> 对象，最后返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">29</span> invokevirtual #<span class="hljs-number">12</span> &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt;<br><span class="hljs-number">32</span> astore_2<br><span class="hljs-number">33</span> getstatic #<span class="hljs-number">3</span> &lt;java/lang/System.out : Ljava/io/PrintStream;&gt;<br><span class="hljs-number">36</span> aload_2<br><span class="hljs-number">37</span> invokevirtual #<span class="hljs-number">17</span> &lt;java/io/PrintStream.println : (Ljava/lang/String;)V&gt;<br><span class="hljs-number">40</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<p>这就是代码的字节码层面的全部经过</p>
<p>所以这段代码等价于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">mango</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;mango&quot;</span>;  <br><span class="hljs-type">StringBuilder</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();  <br>s.append(<span class="hljs-string">&quot;abc&quot;</span>);  <br>s.append(mango);  <br>s.append(<span class="hljs-string">&quot;def&quot;</span>);  <br>s.append(<span class="hljs-number">47</span>);  <br>System.out.println(s.toString());<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<ul>
<li>字符串拼接操作时使用的不一定是 <code>StringBuilder</code>，如果拼接符号左右都是字符串常量或者常量引用，那么还是会使用编译器优化，结果放在字符串常量池中。</li>
<li>针对于 <code>final</code> 修饰类、方法和基本数据类型、引用数据类型的量的结构时，能使用 <code>final</code> 则尽量使用上</li>
</ul>
<p>看下这个例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 为了说明用final声明的变量重载时不会自动使用new创建  </span><br><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">ConcatenationTest3</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;a&quot;</span>;  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;b&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> s1 + s2;  <br>    System.out.println(s3 == s4);<span class="hljs-comment">//true  </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，最终输出的还是 true，说明 s4 还是直接指向了字符串常量池。</p>
<h2 id="拼接的效率"><a href="#拼接的效率" class="headerlink" title="拼接的效率"></a>拼接的效率</h2><p>具体效率的比较可以参考[[2. 重载 + 与StringBuilder]]</p>
<h1 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern 方法"></a>intern 方法</h1><h2 id="官方解释"><a href="#官方解释" class="headerlink" title="官方解释"></a>官方解释</h2><p>Returns a canonical representation for the string object.<br>A pool of strings, initially empty, is maintained privately by the class String.<br>When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals (Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.<br>It follows that for any two strings s and t, <code>s.intern() == t.intern()</code> is true if and only if <code>s.equals(t)</code> is true.<br>All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the The Java™ Language Specification.<br>Returns:<br>a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.</p>
<p>简单来说，就是调用 <code>intern()</code> 方法的时候，如果字符串常量池中有一个调用 <code>equals</code> 方法返回 <code>true</code> 的字符串，那么会直接返回字符串常量池中的字符串。否则会将 <code>string</code> 对象放入字符串常量池，然后将 <code>reference</code> 返回。</p>
<p>并且当前仅当 <code>s.equals(t)</code> 时 <code>s.intern() == t.intern()</code></p>
<h2 id="intern-的使用（jdk6-vs-jdk7-x2F-8）"><a href="#intern-的使用（jdk6-vs-jdk7-x2F-8）" class="headerlink" title="intern() 的使用（jdk6 vs jdk7&#x2F;8）"></a><code>intern()</code> 的使用（jdk6 vs jdk7&#x2F;8）</h2><p>如果不是用双引号声明的 <code>String</code> 对象，可以使用 <code>String</code> 提供的 <code>intern</code> 方法： <code>intern</code> 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。</p>
<p>也就是说，如果在任何字符串上调用 <code>String.intern()</code> 方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。</p>
<h2 id="new-String-时会创建几个对象"><a href="#new-String-时会创建几个对象" class="headerlink" title="new String 时会创建几个对象"></a><code>new String</code> 时会创建几个对象</h2><p>这个问题其实可以分为两个子问题：</p>
<ol>
<li><code>new String(&quot;ab&quot;)</code> 会创建几个对象</li>
<li><code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code> 会创建几个对象</li>
</ol>
<p>首先来看第一个问题：</p>
<h3 id="new-String-quot-ab-quot-会创建几个对象"><a href="#new-String-quot-ab-quot-会创建几个对象" class="headerlink" title="new String(&quot;ab&quot;) 会创建几个对象"></a><code>new String(&quot;ab&quot;)</code> 会创建几个对象</h3><p>这个问题其实应该很简单，一定会创建两个</p>
<ol>
<li>在字符串常量池中放入一个 <code>&quot;ab&quot;</code> 字符串</li>
<li><code>new</code> 的这个对象，在堆中。</li>
</ol>
<p>那么深入思考一下，你怎么证明这件事呢？</p>
<p>答案： 看<strong>字节码</strong>！</p>
<p>这里我们先看源代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> CoachHe  </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/12/16 00:04  </span><br><span class="hljs-comment"> **/</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewString</span> &#123;  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure>

<p>非常简单，就是 <code>new</code> 了一个 <code>String</code> 类型变量。那么来看他的字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java/lang/String&gt;<br> <span class="hljs-number">3</span> dup<br> <span class="hljs-number">4</span> ldc #<span class="hljs-number">3</span> &lt;ab&gt;<br> <span class="hljs-number">6</span> invokespecial #<span class="hljs-number">4</span> &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;<br> <span class="hljs-number">9</span> astore_1<br><span class="hljs-number">10</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<p>这里在 [[1. 字符串概述]]对其进行过了比较详细的分析，仅就创建对象而言，一共有两个步骤创建了对象。</p>
<ol start="0">
<li><code>new</code> 了一个 <code>String</code> 对象</li>
<li>将 <code>#3</code> 指向的字符串常量的引用加入到栈顶中，在这里若 <code>#3</code> 指向的字符串常量没有被加载到字符串常量池中，则会创建一个常量池中的对象。</li>
</ol>
<p>因此若是 <code>#3</code> 指向的字符串常量没有被加载过，那么一共就会创建两个对象，如果已经有对象被创建了，那么就只会创建 1 个对象。</p>
<p>使用 <code>ldc</code> 将常量池中字符串 <code>abc</code> 的引用放入操作数栈中，注意，在这里 <code>ldc</code> 会触发对其符号引用的解析操作，具体可以看 [[7.3 类加载的过程]]，这里会创建一个字符串 <code>abc</code> 对应的对象并将其放入字符串常量池中。</p>
<p>那么此时我们可以来回答第二个问题：</p>
<h3 id="new-String-quot-a-quot-new-String-quot-b-quot-会创建几个对象"><a href="#new-String-quot-a-quot-new-String-quot-b-quot-会创建几个对象" class="headerlink" title="new String(&quot;a&quot;) + new String(&quot;b&quot;) 会创建几个对象"></a><code>new String(&quot;a&quot;) + new String(&quot;b&quot;)</code> 会创建几个对象</h3><p>同样的，我们可以来看它的字节码：</p>
<p>源代码同样很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> CoachHe</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@date</span> 2022/12/16 00:04</span><br><span class="hljs-comment"> **/</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NewString</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">//        String str = new String(&quot;ab&quot;);</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后看其字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"> <span class="hljs-number">0</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">2</span> &lt;java/lang/StringBuilder&gt;<br> <span class="hljs-number">3</span> dup<br> <span class="hljs-number">4</span> invokespecial #<span class="hljs-number">3</span> &lt;java/lang/StringBuilder.&lt;init&gt; : ()V&gt;<br> <span class="hljs-number">7</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java/lang/String&gt;<br><span class="hljs-number">10</span> dup<br><span class="hljs-number">11</span> ldc #<span class="hljs-number">5</span> &lt;a&gt;<br><span class="hljs-number">13</span> invokespecial #<span class="hljs-number">6</span> &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;<br><span class="hljs-number">16</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">19</span> <span class="hljs-keyword">new</span> #<span class="hljs-number">4</span> &lt;java/lang/String&gt;<br><span class="hljs-number">22</span> dup<br><span class="hljs-number">23</span> ldc #<span class="hljs-number">8</span> &lt;b&gt;<br><span class="hljs-number">25</span> invokespecial #<span class="hljs-number">6</span> &lt;java/lang/String.&lt;init&gt; : (Ljava/lang/String;)V&gt;<br><span class="hljs-number">28</span> invokevirtual #<span class="hljs-number">7</span> &lt;java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;&gt;<br><span class="hljs-number">31</span> invokevirtual #<span class="hljs-number">9</span> &lt;java/lang/StringBuilder.toString : ()Ljava/lang/String;&gt;<br><span class="hljs-number">34</span> astore_1<br><span class="hljs-number">35</span> <span class="hljs-keyword">return</span><br></code></pre></td></tr></table></figure>

<p>可以看到，首先是 <code>new</code> 了一个 <code>StringBuilder</code>，接着 <code>new</code> 了字符串 <code>&quot;a&quot;</code> 对应的 <code>String</code> 对象（此时还会创建一个字符串常量池中对应的 <code>&quot;a&quot;</code> 对象，将其放入字符串常量池中），<code>StringBuilder</code> 调用了 <code>append</code> 方法，然后 <code>new</code> 了字符串 <code>&quot;b&quot;</code> 对应的 <code>String</code> 对象 (同理，这里和上一个字符串一样的操作)，然后再次调用了 <code>StringBuilder</code> 的 <code>append</code> 方法，最后调用了 <code>StringBuilder</code> 的 <code>toString ()</code> 方法再 <code>new</code> 了一个返回的 <code>String</code> 对象。</p>
<p>因此一共有 6 个对象被创建了</p>
<ol>
<li><code>new</code> 的 <code>StringBuilder()</code></li>
<li><code>new</code> 的 <code>String()</code></li>
<li>常量池中的 <code>&quot;a&quot;</code></li>
<li><code>new</code> 的 <code>String()</code></li>
<li>常量池中的 <code>&quot;b&quot;</code></li>
<li><code>toString()</code> 方法 <code>new</code> 的一个 <code>String</code> 对象，也就是 <code>new String(&quot;ab&quot;)</code></li>
</ol>
<p>注意，执行完之后，字符串常量池中没有 <code>&quot;ab&quot;</code> 字符串，同样可以看字节码得到，因为没有 <code>ldc ab</code> 的操作</p>
<h2 id="一个面试题"><a href="#一个面试题" class="headerlink" title="一个面试题"></a>一个面试题</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Created with IntelliJ IDEA.</span><br><span class="hljs-comment"> * User: coachhe</span><br><span class="hljs-comment"> * Date: 2022/12/15</span><br><span class="hljs-comment"> * Time: 20:09</span><br><span class="hljs-comment"> * Description:</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Intern</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>);<br>        s.intern(); <span class="hljs-comment">// 调用此方法之前字符串常量池中已经存在1</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;1&quot;</span>;<br>        System.out.println(s == s2); <span class="hljs-comment">// false</span><br><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;2&quot;</span>); <span class="hljs-comment">// 执行完之后字符串常量池中不存在&quot;12&quot;，和jdk版本无关</span><br>        s3.intern(); <span class="hljs-comment">// jdk6： 在字符串常量池中生成新对象&quot;11&quot;， jdk7：在字符串常量池中生成堆中对象的引用</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;12&quot;</span>; <span class="hljs-comment">// s4变量记录的地址：使用的上一行代码执行时，在常量池中生成的&quot;11&quot;的地址</span><br>        System.out.println(s3 == s4); <span class="hljs-comment">// jdk6及以前:false, jdk7及以后:true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上半段代码很容易理解，首先创建了一个堆中的对象，并且在字符串常量池中创建了字符串常量 <code>&quot;1&quot;</code>，因此在执行第二行 <code>s.intern()</code> 时，这里不会有什么效果，然后 <code>String s2 = &quot;1&quot;</code> 时创建了字符串常量池中变量 <code>&quot;1&quot;</code> 的引用 <code>s2</code>，这个和堆中的对象 <code>s</code> 显然没有什么关系，因此直接输出 false，这里无论是何种版本的 jdk 都是相同的结果。</p>
<p>难点在第二段代码， 这里有一个点需要注意，就是当我们使用 jdk6 以及之前的版本执行时，这里两个都会返回 false，但是在 jdk7 以及之后，这里都是第一个为 false，第二个为 true。</p>
<p>这是因为 jdk7 之后对这里做了一个优化。</p>
<p>jdk6 以及之前，执行 <code>s3.intern()</code> 时会在字符串常量池中创建一个 <code>&quot;12&quot;</code> 对象，然后直接返回，因此接下来执行 <code>String s4 = &quot;12&quot;</code> 时创建了一个字符串常量池中变量 <code>&quot;12&quot;</code> 的引用 <code>s4</code>，这个引用和 <code>s3</code> 显然也没有什么关系，因此会输出 false。</p>
<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221216003637.png" srcset="/img/loading.gif" lazyload width = "70%" />

<p>但是到了 jdk7 之后执行 <code>s3.intern()</code> 之后不会在字符串常量池中创建对应的字符串常量，而是会创建一个 <code>reference</code>，指向堆中 <code>new String(&quot;12&quot;)</code> 的对象。因此接下来 <code>s4</code> 也会指向堆中的对象，因此输出了 true。</p>
<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221216004129.png" srcset="/img/loading.gif" lazyload width = "70%" />

<p>面试题的拓展:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 何时执行intern方法的影响  </span><br><span class="hljs-meta">@Test</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internTest2</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s3</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;1&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;8&quot;</span>);  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s4</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;18&quot;</span>;  <br>    s3.intern();  <br>    System.out.println(s3 == s4); <span class="hljs-comment">// false  </span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，和上面唯一的不同是 <code>String s4 = &quot;18&quot;</code> 往前提了一行。但是导致输出的结果变为 false。这是因为执行这行代码时字符串常量池中是没有 <code>&quot;18&quot;</code> 这个常量的，因此会创建并返回地址，那么此时和堆中的对象就完全没有关系了，再执行 <code>s3.intern()</code> 时因为字符串常量池中已经有了 <code>&quot;18&quot;</code>, 因此没有任何作用。</p>
<h2 id="总结-String-中-intern-方法的使用"><a href="#总结-String-中-intern-方法的使用" class="headerlink" title="总结 String 中 intern() 方法的使用"></a>总结 String 中 <code>intern()</code> 方法的使用</h2><p>jdk1.6 中，将这个字符串对象尝试放入常量池。 </p>
<ul>
<li>如果常量池中有，并不会放入，返回已有的常量池中的对象的地址</li>
<li>如果没有，会把此对象<strong>复制一份，放入常量池</strong>，并返回常量池中的对象地址</li>
</ul>
<p>jdk1.7 起，将这个字符串对象尝试放入常量池。</p>
<ul>
<li>如果常量池中有，并不会放入，返回已有常量池中的对象的地址</li>
<li>如果没有，则会把<strong>对象的引用地址复制一份，放入常量池</strong>，并返回常量池中的引用地址</li>
</ul>
<h2 id="补充习题"><a href="#补充习题" class="headerlink" title="补充习题"></a>补充习题</h2><p>习题 1：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internTest3</span><span class="hljs-params">()</span>&#123;  <br>    <span class="hljs-type">String</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);  <br>  <br>	<span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> s.intern(); <span class="hljs-comment">// jdk6中：在常量池中创建一个字符串&quot;ab&quot;  </span><br>	                        <span class="hljs-comment">// jdk7及以后：在常量池中没有创建字符串&quot;ab&quot;,而是创建一个引用，指向new String(&quot;ab&quot;)，将此引用返回</span><br>  <br>    System.out.println(s2 == <span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// true  </span><br>    System.out.println(s == <span class="hljs-string">&quot;ab&quot;</span>); <span class="hljs-comment">// jdk1.6及以前: false, jdk1.7及以后：true</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到，和上面很类似，jdk1.6 以前是 false，我们就不多加赘述了，</p>
<p>在 jdk1.7 及以后，执行 <code>String s2 = s.intern()</code> 之后，会在字符串常量池中放入堆的引用并返回，因此 <code>s</code> 和 <code>s2</code> 指向的是同一个堆空间。</p>
<p>习题 2：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internTest4</span><span class="hljs-params">()</span>&#123;  <br><span class="hljs-comment">//        String s1 = new String(&quot;a&quot;) + new String(&quot;b&quot;);  </span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);  <br>        s1.intern();  <br>        <span class="hljs-type">String</span> <span class="hljs-variable">s2</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;ab&quot;</span>;  <br>        System.out.println(s1 == s2);  <br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这里需要关注两种写法的不同，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;ab&quot;</span>);<br></code></pre></td></tr></table></figure>

<p>这种写法在字符串常量池中<strong>会创建 <code>&quot;ab&quot;</code> 字符串常量</strong>，因此执行 intern 是没有效果的，<code>s2</code> 会执行字符串常量池中的 <code>&quot;ab&quot;</code> 字符串常量。因此这里输出的是 false。</p>
<p>但是如果换成了这种写法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">s1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;a&quot;</span>) + <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(<span class="hljs-string">&quot;b&quot;</span>);  <br></code></pre></td></tr></table></figure>

<p>这种方法也会创建一个堆中的 <code>String</code> 对象，但是<strong>不会在字符串常量池中创建字符串常量</strong> <code>&quot;ab&quot;</code>，因此执行 <code>s1.intern()</code> 之后会在字符串常量池中创建一个指向堆中对象的引用，所以 <code>s2</code> 也是这个引用，因此这里会输出 true。</p>
<h2 id="intern-的效率测试"><a href="#intern-的效率测试" class="headerlink" title="intern 的效率测试"></a>intern 的效率测试</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">// 空间效率测试  </span><br>    <span class="hljs-meta">@Test</span>  <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">internTest5</span><span class="hljs-params">()</span>&#123;  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">MAX_COUNT</span> <span class="hljs-operator">=</span> <span class="hljs-number">1000</span> * <span class="hljs-number">10000</span>;  <br>        String[] arr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[MAX_COUNT];  <br>        Integer[] data = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Integer</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>&#125;;  <br>  <br>        <span class="hljs-type">long</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> System.currentTimeMillis();  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; MAX_COUNT; i++) &#123;  <br>            arr[i] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(String.valueOf(data[i % data.length])).intern();  <br><span class="hljs-comment">//            arr[i] = new String(String.valueOf(data[i % data.length]));  </span><br>        &#125;  <br>        <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();  <br>        System.out.println(<span class="hljs-string">&quot;花费的时间为: &quot;</span> + (end - start));  <br>  <br>        <span class="hljs-keyword">try</span> &#123;  <br>            Thread.sleep(<span class="hljs-number">1000000</span>);  <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>            e.printStackTrace();  <br>        &#125;  <br>  <br>    &#125;<br></code></pre></td></tr></table></figure>

<p>通过比较可以得到，使用 <code>intern()</code> 方法可以大量减少生成的对象。</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" class="category-chain-item">编程语言</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/" class="category-chain-item">Java</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%AF%AD%E8%A8%80/" class="category-chain-item">Java语言</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%AF%AD%E8%A8%80/JVM/" class="category-chain-item">JVM</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/Java%E8%AF%AD%E8%A8%80/JVM/%E7%AC%AC2%E7%AB%A0-Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/" class="category-chain-item">第2章 Java内存区域与内存溢出异常</a>
  
  

  

  

  

  

      </span>
    
  
</span>

    </div>
  
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>补充-String和字符串常量池</div>
      <div>http://example.com/2022/12/48259411da1e.html</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>CoachHe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年12月18日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/12/ad9faad19925.html" title="2. 必须创建所有对象">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">2. 必须创建所有对象</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/12/0fba21433ffa.html" title="1. 通过引用操作对象">
                        <span class="hidden-mobile">1. 通过引用操作对象</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
