---
categories:
  - 计算机
  - Linux
  - 网络编程
  - UNP
title: 第6章 IO复用：Select和poll函数  
date: 2022-12-11 17:30:58  
tags: []  

---

# 1. 概述

先来看一下 TCP 发送数据的流程：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211174541.png" width = "50%" />

可以看到，两个应用直接发送信息时，分为三步：
1. 应用 A 把消息发送到缓冲区
2. TCP 发送缓冲区再把消息发送出去，经过网络传递后，消息会发送到 B 服务器的 TCP 接收缓冲区
3. 应用 B 再从 TCP 接收缓冲区中去读取属于自己的数据。

## 区分阻塞 I/O 和非阻塞 I/O 呢？

通过上图我们知道了 TCP 发送数据的流程，那么什么是阻塞 I/O 什么是非阻塞 I/O 呢？

其实，所谓阻塞 IO 就是当应用 B 发起读取数据申请时，在内核数据没有准备好之前，应用 B 会一直处于等待数据状态，直到内核把数据准备好了交给应用 B 才结束。

所谓非阻塞 IO 就是当应用 B 发起读取数据申请时，如果内核数据没有准备好会即刻告诉应用 B，不会让 B 在这里等待。

# 2. IO 模型

## UNIX 下可用的 5 种 I/O 模型的基本区别

- 阻塞式 I/O
- 非阻塞式 I/O
- I/O 复用（`select` 和 `poll`）
- 信号驱动式 I/O（SIGIO）
- 异步 I/O（`POSIX` 的 `aio_` 系列函数）

## 2.1 阻塞式 I/O 模型

最流行的 I/O 模型是阻塞式 I/O (blocking I/O) 模型，目前为止的所有例子都使用该模型。默认情形下，所有套接字都是阻塞的，如下图：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211200746.png" width = "70%" />

在上图中，进程调用 `recvfrom`, 其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。最常见的错误是系统调用被信号中断。我们说进程在从调用 `recvfrom` 开始到它返回的整段时间内是被阻塞的。`recvfrom` 成功返回后，应用进程开始处理数据报。

## 2.2 非阻塞式 I/O 模型

进程把一个套接字设没成非阻塞是在通知内核：当所请求的 I/O 操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211201153.png" width = "70%" />

前三次调用 `recvfrom` 时没有数据返回，因此内核转而立即返回一个 `EWOULDBLOCK` 错误。第四次调用时已有一个数据报准备好，它被复制到应用程序缓冲区，于是 recvfrom 成功返回。我们接着处理数据。

当一个应用像这样对一个非阻塞描述符循环调用 `recvfrom` 时，我们称之为轮询（polling）。

### 缺点

应用程序持续轮询内核 ，以查看某个操作是否就绪。这么做往往消耗大量 CPU 时间，不过这种模型偶尔也会遇到，通常是在专门提供某一种功能的系统中才有。

## 2.3 I/O 复用模型

我们先思考一个问题：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211202411.png" width = "80%" />

如图所示，如果有多个人同时往应用 B 发送消息，这种情况下应用 B 就必须创建多个线程去读取数据，每个线程都会自己去调用 `recvfrom` 去读取数据，那么并发情况下服务很可能一瞬间会收到几十上百万的请求，线程资源完全不可能跟得上，因此出现了 I/O 复用，由一个线程监控多个网络请求，这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211202822.png" width = "70%" />

可以看到，有个专门的询问线程来轮询所有网络请求的数据是否准备完毕，若完毕则分配线程去执行 `recvfrom` 操作。

这其实就是我们常说的 `select`，`poll`、`epoll` 函数，有了这个函数后，应用程序通过调用 `select` 函数就可以同时监控多个网络 I/O，`select` 函数监控的网络 I/O 中只要有任何一个数据状态准备就绪了，`select` 函数就会返回刻度状态，这时询问线程再去通知处理数据的线程，对应线程此时再发起 `recvfrom` 请求去读取数据。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211203133.png" width = "70%" />

### 使用 select 的优缺点

缺点：
由于使用 `select` 需要两个而不是一个系统调用（`select` + `poll`），I/O 复用相比较于之前的阻塞 I/O 和非阻塞 I/O 甚至还稍有劣势。

优点：
使用 `select` 的优势在于我们可以等待多个描述符就绪，对下面描述的信号驱动 I/O 模型很有帮助。

## 2.4 信号驱动 I/O 模型

复用 I/O 模型解决了一个线程可以监控多个网络 I/O 的问题，但是使用 `select` 方式时询问线程会采用轮询的方式来进行监控，这样其实大部分情况下都是无效的，因此衍生出了信号驱动 I/O 模型。

信号驱动 I/O 不是用循环请求询问的方式去监控数据就绪状态，而是当内核数据准备好之后再通知线程数据准备好后的可读状态，当线程收到可读状态的信号后，此时再向内核发起 `recvfrom` 读取数据的请求，因为信号驱动 IO 的模型下应用线程在发出信号监控后即可返回，不会阻塞，所以这样的方式下，一个应用线程也可以同时监控多个网络 I/O。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211204019.png" width = "70%" />

更具体的，在信号驱动 I/O 模型中，我们先开启套接字的信号驱动式 I/O 功能，并通过 `sigaction` 系统调用安装一个信号处理函数。该系统调用将立即返阿我们的进程继续工作，也就是说它没有被阻塞。当数据报准备好读取时，内核就为该进程产生一个 `SIGIO` 信号。我们随后既可以在信号处理函数中调用 `recvfrom` 读取数据报，并通知主循环数据已准备好待处理，也可以立即通知主循环，让它读取数据报。 

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211203818.png" width = "70%" />

## 2.5. 异步 I/O 模型

上面描述的 4 中 I/O 模式中，目前看来最好的就是信号驱动 I/O 模型，但是我们发现，要读取一个数据总是要发起两阶段的请求，第一次发送 `select` 请求，询问数据是否准备好，第二次发送 `receform` 请求读取数据。

那么你有没有想过，是否有一种一劳永逸的方案，我只要发送一个请求告诉内核我要读取什么数据，然后我就不管了，剩下的事情由内核来帮我完成？

答案是存在的。这就是异步 I/O 模型，在这种模型中，应用只需要向内核发送一个 `read` 请求, 告诉内核它要读取数据后即刻返回；内核收到请求后会建立一个信号联系，当数据准备就绪，内核会主动把数据从内核复制到用户空间，等所有操作都完成之后，内核会发起一个通知告诉应用，我们称这种一劳永逸的模式为异步 I/O 模型。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211211526.png" width = "70%" />

### 工作机制

告知内核启动某个操作，并让内核在整个操作（包括将数据从内核复制到我们自己的缓冲区）完成后通知我们。

### 异步 I/O 和同步 I/O 的主要区别

信号驱动式 I/O 是由内核通知我们何时可以启动一个 I/O 操作，而异步 I/O 模型是由内核通知我们 I/O 操作何时完成

也就是说，上面介绍的四种 I/O 模型（阻塞 I/O + 非阻塞 I/O + I/O 复用 + 信号驱动 I/O），都是当数据准备好时内核通知我们可以去调用 `recvfrom` 方法去读取数据了，但是异步 I/O 是当 I/O 操作已经完成了之后才会给我们发送通知。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211212115.png" width = "70%" />

我们调用 `aio`. `read` 函数（POSIX 异步 I/O 函数以 `aio_` 或 `lio_` 开头），给内核传递描述符、缓冲区指针、缓冲区大小（与 `read` 相同的三个参数）和文件偏移（与 lseek 类似），并告诉内核当整个操作完成时如何通知我们。该系统调用立即返回，而且在等待 I/O 完成期间，我们的进程不被阻塞。

## 五种 I/O 模型的对比

我们知道，一个 I/O 操作一共有两个阶段：
1. 获取网络 I/O 状态，确认是否可以读取
2. 发送 `recvfrom` 系统调用来将数据获取至内核，然后将数据从内核复制到调用者的缓冲区

前 4 种模型的主要区别在第一阶段，因为他们的第二阶段是相同的：从在数据从内核复制到调用者的缓冲区期间，进程阻塞与 `recvfrom` 调用。相反，异步 I/O 模型在这两个阶段都要处理，从而不同于其他 4 种模型。

## 同步 I/O 和异步 I/O 的对比

从线程角度出发
- 同步 I/O 操作（synchronous I/O opetation）每个线程模型都有一个连接
	- 并发度很高
	- 大量线程产生
- 异步 I/O 操作（asynchronous 1/0opetation）每个服务器有一个线程来处理 I/O
	- 更多的线程经常发挥作用（同步 I/O 很多线程是没有用的）
	- 应用处理客户端上下文的转换

posix 把这两个术语定义如下：
- 同步 I/O 操作（synchronous I/O opetation）导致请求进程阻塞，直到 I/0 操作完成；
- 异步 I/O 操作（asynchronous 1/0opetation）不导致请求进程阻塞。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211212926.png" width = "70%" />

根据上述定义，我们的前 4 种模型——阻塞式 I/O 模型、非阻塞式 I/O 模型、I/O 复用模型和信
号驱动式 1/0 模型都是同步 I/O 模型，因为其中真正的 I/O 操作 （`recvfrom`）将阻塞进程。只有异
步 1/0 模型与 POSIX 定义的异步 I/O 相匹配。

