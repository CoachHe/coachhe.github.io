--- 

title: 第6章 IO复用：Select和poll函数  
date: 2022-12-11 17:30:58  
tags: []  

---

# 1. 概述

先来看一下 TCP 发送数据的流程：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211174541.png" width = "50%" />

可以看到，两个应用直接发送信息时，分为三步：
1. 应用 A 把消息发送到缓冲区
2. TCP 发送缓冲区再把消息发送出去，经过网络传递后，消息会发送到 B 服务器的 TCP 接收缓冲区
3. 应用 B 再从 TCP 接收缓冲区中去读取属于自己的数据。

## 区分阻塞 I/O 和非阻塞 I/O 呢？

通过上图我们知道了 TCP 发送数据的流程，那么什么是阻塞 I/O 什么是非阻塞 I/O 呢？

其实，所谓阻塞 IO 就是当应用 B 发起读取数据申请时，在内核数据没有准备好之前，应用 B 会一直处于等待数据状态，直到内核把数据准备好了交给应用 B 才结束。

所谓非阻塞 IO 就是当应用 B 发起读取数据申请时，如果内核数据没有准备好会即刻告诉应用 B，不会让 B 在这里等待。

# 2. IO 模型

## UNIX 下可用的 5 种 I/O 模型的基本区别

- 阻塞式 I/O
- 非阻塞式 I/O
- I/O 复用（`select` 和 `poll`）
- 信号驱动式 I/O（SIGIO）
- 异步 I/O（`POSIX` 的 `aio_` 系列函数）

## 2.1 阻塞式 I/O 模型

最流行的 I/O 模型是阻塞式 I/O (blocking I/O) 模型，目前为止的所有例子都使用该模型。默认情形下，所有套接字都是阻塞的，如下图：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211200746.png" width = "70%" />

在上图中，进程调用 `recvfrom`, 其系统调用直到数据报到达且被复制到应用进程的缓冲区中或者发生错误才返回。最常见的错误是系统调用被信号中断。我们说进程在从调用 `recvfrom` 开始到它返回的整段时间内是被阻塞的。`recvfrom` 成功返回后，应用进程开始处理数据报。

## 2.2 非阻塞式 I/O 模型

进程把一个套接字设没成非阻塞是在通知内核：当所请求的 I/O 操作非得把本进程投入睡眠才能完成时，不要把本进程投入睡眠，而是返回一个错误。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211201153.png" width = "70%" />

前三次调用 `recvfrom` 时没有数据返回，因此内核转而立即返回一个 `EWOULDBLOCK` 错误。第四次调用时已有一个数据报准备好，它被复制到应用程序缓冲区，于是 recvfrom 成功返回。我们接着处理数据。

当一个应用像这样对一个非阻塞描述符循环调用 `recvfrom` 时，我们称之为轮询（polling）。

### 缺点

应用程序持续轮询内核 ，以查看某个操作是否就绪。这么做往往消耗大量 CPU 时间，不过这种模型偶尔也会遇到，通常是在专门提供某一种功能的系统中才有。

## 2.3 I/O 复用模型

我们先思考一个问题：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211202411.png" width = "80%" />

如图所示，如果有多个人同时往应用 B 发送消息，这种情况下应用 B 就必须创建多个线程去读取数据，每个线程都会自己去调用 `recvfrom` 去读取数据，那么并发情况下服务很可能一瞬间会收到几十上百万的请求，线程资源完全不可能跟得上，因此出现了 I/O 复用，由一个线程监控多个网络请求，这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221211202822.png" width = "70%" />

可以看到，有个专门的询问线程来轮询所有网络请求的数据是否准备完毕，若完毕则分配



