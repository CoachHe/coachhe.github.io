# 前言：APUE的实验环境的搭建

## APUE源代码下载
  [http://www.apuebook.com/code3e.html](http://www.apuebook.com/code3e.html)
  得到源代码压缩包文件src.tar.gz
## 保存在自己的工作目录并解压·
  ```shell
  cp src.3e.tar.gz ~ 
  //作用是将其放入工作环境中
  tar -xzvf src.tar.gz
  //作用是解压
  ```
## 进入apaue.2e查看README
  第二版中需要进行更改workspace的操作，但是第三版似乎不需要（至少我没有遇见），因此这步可以跳过

 ## 将入lib库执行make
   ```shell
   cd lib
   make
   ```
   执行之后会得到静态库lib apue.a
  ![](https://pic.downk.cc/item/5fc6364bf81f7e3bd97ee21d.png)
   将其复制到/usr/lib中
   ```shell
   sudo cp apue.a  /usr/lib
   ```

## 把头文件apue/h复制到/usr/include中
   我们所需要的头文件在apue.2e中的include文件中，需要将其复制到/usr/include中，这样gcc编译期间就能顺利找到头文件apue.h了。
   ```shell
   sudo cp include/apue.h /usr/include
   ```

## 到这里准备工作就做完了，尝试进行一次编译
   ```shell
   cd filedir                 //进入随意一个文件库
   gcc -o myls ls1.c -lapue   //进行编译
   ```
   最后一句-lapue必须加上，含义是去掉err部分
   这里我们可以看到，正确输出了myls，并且编译正常
![](https://pic.downk.cc/item/5fc63689f81f7e3bd97f1e08.png)

   **注意**
      第二版的各章的源代码直接放在了apue.2e里，第三版各章的源代码放在figlinks文件夹下。

# 2 UNIX基础知识

## 1 引言
本章从程序员的角度快速浏览UNIX，对舒总引用的一些术语和概念进行简要的说明并给出实例。在以后各章中，将对这些概念做更详细的说明。

## 2 UNIX体系结构
![WX20200414-151549@2x.png](https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=3321797453,2172960764&fm=26&gp=0.jpg)

如图所示，操作系统所对应的是内核（kernel）部分，内核的接口被称为系统调用。公用函数库构建在系统调用接口之上，对系统调用进行封装，应用程序既可使用公共函数库，也可使用系统调用。

**说人话**：操作系统=内核，需要用系统调用才能使用操作系统为我们工作，例如进行内存的分配，设备的IO等。shell和公共函数都能直接进行系统调用，应用程序可以直接进行系统调用，也可以使用shell和公共函数库里的函数，从而间接进行系统调用。


## 3 登录
### 登录名
用户在登录UNIX系统键入用户名和密码时，系统在其口令文件中查看登录名：
口令文件通常在/etc/passwd中：

### shell
shell是一个命令行解释器，读取用户输入，然后执行命令。shell的用户输入通常来自终端（交互式shell），有时则来自于文件（成为shell脚本）。

## 4 文件和目录
   #### 文件系统
   UNIX文件系统是目录和文件的一种层次结构，所有东西的起点是成为**根**（root）的目录，这个目录的名称是一个字符“/”。
   #### 根目录的文件
  主要由以下几个文件组成
   /bin：基本命令的二进制文件  
   /boot：自动自动的静态代码  
   /dev：device files：设备代码  
   /etc：host-specific system configuration:主机特定的系统配置  
  &emsp; /etc/opt：/opt的配置文件  
  &emsp; /etc/X11：X Window System的配置文件  
  &emsp; /etc/sgml：SGML的配置文件  
  &emsp; /etc/xml：XML的配置文件  
   /home：家目录  
   /lib：  
   /media  
   /mnt  
   /root：管理文件  
   /tmp：暂存文件目录  
   **/usr**：用户目录  

   ####  用户目录
   /usr/bin：主要作用是放置自己安装的命令，例如python，perl   
   /usr/include：包括标准头文件（也就是APUE.h放置的地方，gcc会自动找到这个头文件）  
   /usr/lib：包括我们的库和安装包（也就是APUE.a放置的地方，是一个静态库）  
   /usr/src：放一些源文件（user source）  
   更加具体的，请参考FHS
   [FHS下载链接](http://www.pathname.com/fhs/pub/fhs-2.3.pdf)


## 5 输入和输出
### 文件描述符
   文件描述符（file descriptor）通常是一个非常小的非负整数，内核用以表示一个特定进程正在访问的文件。当内核打开一个现有文件或者创建一个新文件时，它都返回一个文件描述符，在读写文件时，可以使用这个文件描述符  
   **理解**  
  &emsp;&emsp;0,1,2叫文件描述符；Linux中，每打开一个文件都有一个小的整数与之对应，就是文件描述符！  
&emsp;&emsp;0 是标准输入的 （stdin）  
&emsp;&emsp;1 是标准输出的 （stdout）  
&emsp;&emsp;2 是标准报错输出的 （stderr）  
&emsp;&emsp;'<'是输入重定向符  
&emsp;&emsp;'>'是输出重定向符  
### 标准输入、标准输出和标准错误
   按照惯例，每当运行一个新程序的时候，所有的shell都会为其打开三个文件描述符，即**标准输入**、**标准输出**和**标准错误**，如果不做特殊处理，执行一个简单的命令ls，那么三个描述符都是指向终端的。大多数shell都提供一种方法，使任何一个或所有者三个描述符都能重新定向到某个文件。例如：
   ```shell
   ls > file.list
   ```
   执行ls命令，其标准输出重新定向到名为file.list的文件
### 不带缓冲的I/O（unbuffered I/O）
不带缓冲的I/O又称为非标准I/O，含义是在函数中需要进行buffer size的确认。
#### 典型函数
open  
read  
write  
lseek  
close  
提供了不带缓存的I/O,这些函数都使用文件描述符。
#### 举例
![](https://pic.downk.cc/item/5fc636f5f81f7e3bd97f4dec.png)
在这里可以看见，需要预先设定一个BUFFSIZE，这对程序的性能是有影响的。

### 标准I/O
带缓存的I/O也称为标准I/O，含义是不需要自己去定义buffer size，库函数会帮助自己定义好。
#### 举例

在这里可以看见，不需要预先设定BUFFSIZE了，库函数都会帮自己做好。因此对于程序员来说方便了许多。



## 6 程序和进程
### 1 程序
程序是一个存储在磁盘上某个目录中的可执行文件。内核使用exec函数将程序读入内存，并执行程序。
**理解**
程序只是一段代码，并没有动起来，内核使用exec函数将这段程序（代码）读入内存并执行之后程序变成了进程，也就是说，进程是动起来的程序。
### 2 进程和进程ID
程序的执行实例叫做进程，某些操作系统用任务表示正在被执行的程序。
UNIX系统确保每个进程都有一个唯一的数字标识符，称为进程ID，进程ID总是一个非负整数。
#### 实例
![](https://pic.downk.cc/item/5fc636c3f81f7e3bd97f43ab.png)
如图所示，将该程序会调用getpid得到其进程ID进行打印，可以看见，随着多次调用该程序，内核多次使用exec函数将程序读入内存并执行，进程ID也会随之增大。

### 3 进程控制
有三个用户进程控制的主要函数：fork、exec和waitpid。  
fork用于创建一个新锦成。新进程是调用进程的一个副本，调动进程被称为父进程，新创建的进程被称为子进程。  
#### **注意**
fork调用一次返回两个进程ID，对父进程返回子进程的进程ID，对子进程返回0。  
exec函数是内核调用以生成新的进程的。  
waitpid是父进程用来等待子进程结束所调用的，参数指定要等待的进程，当该进程停止时得到通知。  

#### 实例
![](https://pic.downk.cc/item/5fc636cef81f7e3bd97f4639.png)

### 4 线程和线程ID
与进程先攻，线程也用ID表示。但是，线程ID只在它所属的进程里起作用。一个进程中的线程ID在另一个进程中没有意义。

## 7 出错处理
当UNIX系统函数出错时，通常会返回一个负值，整型变量errno通常被设置为具有特定信息的值。
### errno的使用规则
1. 如果没有出错，其值不会被例程清零。因此，仅当函数的返回值指明出错时，才检验其值。
2. 任何函数都不会讲errno的值设置为0，而且在<errno.h>头文件中定义的所有常量都不为0。
### errno的打印
C标准定义了两个函数来打印出错信息
1. strerror函数将errno映射为一个出错消息字符串，并返回此字符串的指针
2. perror函数基于errno的当前值，在标准错误上产生一条错误信息然后返回
#### 实例
![](https://pic.downk.cc/item/5fc63661f81f7e3bd97ee741.png)
如图所示，可以看到采用了两种方式进行打印errno。
**注意**：我们将程序名作为参数传递给perror。这是标准的UNIX惯例。使用这种方法，在程序作为管道的一部分执行时，例如：
```shell
prog1 < inputfile | prog2 | prog3 > outputfile
```
我们就能分清3个程序中的哪一个产生了一条特定的出错信息。
### 出错恢复
   可将<errno.h>中定义的各种出分为两类：致命性的和非致命性的。
   对于非致命出错，是可能恢复的，例如典型恢复操作是延迟一段时间后重试（例如网络不可用）

## 8 用户标识
### 1 用户ID
   口令文件登录项中的用户ID是一个数值，它向系统标识各个不同的用户。
   **注意**：用户标识为0的用户为根用户或者超级用户。也就是登录名为root的用户，这种用户的特权称为超级用户特权。

### 2 组ID
   口令文件登录项也包括用户的组ID，它是一个数值。
   **注意**：多个用户ID可以是同一个组ID，组被用于将若干用户集合到项目或部门中去。
   族文件将组名映射为数值的组ID。组文件通常是/etc/group。

### 实例
![](https://pic.downk.cc/item/5fc6371af81f7e3bd97f56b7.png)




## 9 信号
   信号用于通知进程发生了某种情况。例如进程执行除法时发现除数为0，则将名为SIGFPE（浮点异常）的信号发送给该进程。
### 处理信号的方式
1. 忽略信号（不推荐）
2. 系统默认方式处理（例如除以0的默认是终止进程）
3. 捕捉信号进行处理：提供一个函数来进行处理。



## 10 时间值
历史上，UNIX系统使用过两种不同的时间值
1. 日历时间
   用date函数，根据参数的不同可以表达不同的时间。例如：
```shell
date //显示当前时间
date +%s //显示自协调世界时（UTC，1970年1月1日00:00:00)这个特定的时间以来所经历的秒数累计值。
```


2. 进程时间
   也被称为CPU时间，用以度量进程使用的中央处理器资源。

## 11 系统调动和库函数
《UNIX程序员手册》第三部分定义了程序员可以使用的通用库函数。虽然这些函数可能会调用一个或多个内核的系统调用，但是它们并不是内核的入口点。
例如printf函数函数会调用write系统调用以输出一个字符串，但strcpy（复制一个字符串）和atoi（将ASCII转换成正数）并不使用任何内核的系统调用。**也就是说**：库函数可能涉及系统调用，也可能不涉及系统调用，可能需要调用内核，也可能不需要调用内核。
### 系统调用和库函数的区别
库函数可以替换，但是系统调用通常是不能替换的。
   **例如**我们可以有多种输出方式，但是核心系统调用write是不能替换的。
   **再比如**UNIX系统只提供一个时间的系统调用：也就是返回自协调世界时以来所经历的秒数累计值，但是可以通过后续的多种库函数处理得到我们所需要的结论























