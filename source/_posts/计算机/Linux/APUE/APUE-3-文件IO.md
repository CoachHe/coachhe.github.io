---
categories:
  - 计算机
  - Linux
  - APUE
---
# 1 引言
本章开始讨论UNIX系统，先说明可用的文件I/O函数-打开文件、读文件、写文件等。
UNIX系统中的大部分文件I/O只需要用到5个函数：open、read、write、lseek以及close。然后说明不同缓冲长度对read和write函数的影响。

**不带缓冲的定义**：术语不带缓冲指的是每个read和write都调用内核中的一个系统调用。
也就是说，不带缓冲的I/O就是其中的I/O操作都是直接对内核进行系统调用的。而带缓冲的I/O就不会直接对内核调用。

# 2 文件描述符
对于内核而言，所有打开的文件都通过文件描述符引用。
## 流程
open()/create()/socket等函数**生成**文件描述符  
&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;&darr;  
read()/write()等函数**使用**文件描述符

## 对应
按照惯例，UNIX系统shell把文件描述符0余进程的标准输入相关联，文件描述符1与标准输出相关联，文件描述符2与标准错误相关联。  
#### **解释**  
Linux shell在创建一个进程的时候，会自动生成三个文件，分别是标准输入、输出和标准错误，并且生成三个文件描述符与其相对应。之后我们操作输入输出其实是直接对这些文件操作，而不是直接I/O。

## 回顾
![fig1.4](https://pic4.zhimg.com/80/v2-3691c953c62dba149ea2cc16e190b7f7_1440w.jpg)
这是fig1.4.c，作用是模拟将标准输入写到标准输出中。里面就用到了STDIN_FILENO，默认为0。

## 3 函数open和openat
调用open和openat可以打开或创建一个文件。
```Cpp
#include <fcnt1.h>

int open(const char *path, int olafg. ... /* mode_t */

int openat(int fd, const char *path, int 0flay, ... /* mode_t mode */;
```
两函数的返回值：若成功则返回文件描述符，若出错则返回-1.
### 参数说明
1. path是要打开或创建的文件的名字
2. *path表示打开或创建的文件所在的地址
3. oflag参数用来说明此函数的多个选项，用下列一个或者多个常量进行“或”运算构成oflag参数（在<fcntl.h>头文件中定义）
   **理解**：也就是说，多个常量是可以同时指定的，例如O_RDONLY || O_CREATE就是一个oflg参数形式，表示这是只读打开的，并且如果没有这个文件就创建它。
4. fd参数：将open和openat区分开
   (1) 若path是**绝对路径名**，这种情况open和openat含义相同，fd参数被忽略
   (2) 若path是**相对路径名**，这种情况fd是相对路径在文件名系统中的开始地址。fd参数通过打开相对路径所在目录来获取。
   (3) 若path是**相对路径名**，且fd具有特殊值AT_FDCWD。openat和open效果类似。

## openat希望解决的问题
1. 让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。
2. 避免TOCTTOU错误。

## 文件名和路径名截断
如果试图创建的文件名超过NAME_MAX，那么早期UNIX系统会进行截断，也就是指保留14个。
### 带来的问题
这样无法判断是否该文件名被截断过


# 4 函数create（不建议）
```C
#include <functl.h>
int create (const char *path, mode_t mode);
```
等价于
```C
open(path, OWRONLY | O_CREATE |O_TRUNC, mode)
```
因此可以被open替代
##不足之处
   它以制度方式打开所创建的文件，需要创建一个文件，然后写，然后读，则必须的步骤：
   ```shell
   create
   close
   open
   ```
   很复杂，现在不建议使用。

# 5 函数close（少用）
关闭一个进程时还会释放该进程加在文件上的所有锁。
进程终止时内核自动关闭它所有的打开文件，因此很多程序都利用了这一点，而不是显式地使用close关闭打开文件。  
#### **理解**
我们可以让文件一直开着，知道我们这个进程终止了，自动所有文件都会全部关掉，而不用中途显式地使用close了。


# 6 函数lseek
## 当前文件偏移量(current file offset)
通常是一个非负整数，用以度量从文件开始处计算的字节数。通常，读写操作都从当前文件偏移处开始。
## lseek函数作用
调用lseek可以显式地为一个打开文件设置偏移量    
#### **理解**  
1. 前提是这个文件已经打开，也就是说lseek不能打开文件，只能作用于一个打开的文件
2. 作用是为这个打开的文件设置一个偏移量，也就是确定该文件的偏移量具体位于哪个位置。
## lseek函数形式
lseek函数如下：
```C
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);
```
### 参数说明
fd：文件标识符
offset：偏移量，其解释是根据whence来决定的
whence：分三种情况：
1. whence=SEEK_SET，则该文件的偏移量为距文件开始出offset个字节
2. whence=SEEK_CUR，则该文件偏移量设置为当前值加offset，offset**可正可负**。
3. whence=SEEK_END，则该文件偏移量设置为文件长度加offset，offset**可正可负**。

若lseek成功执行，则返回新的文件偏移量
### 举例
例如
```C++
off_t currpos;;
currpos = lseek(fd, 0, SEEK_CUR);
```
第一行先初始化一个currpos，接着第二行执行lseek(fd,0,SEEK_CUR);SEEK_CUR代表将文件偏移量设置为当前值加上offset。因此这两行代码其实就是得到了当前文件的偏移量。并且还可以用来测试当前的文件是否可以设置偏移量。

例3.1


**注意**
当前文件偏移量有正有负，因此需要比较lseek的返回值时应当谨慎，不要测试它是否小于0，而是测试是否等于-1。

## 空洞
文件偏移量可以大于文件的当前长度，在这种情况下，对该文件的下一次写将加长该文件，并在文件中构成一个空洞。位于文件中但没有写过的字节都被读为0。
**理解**
例如一个文件长度为5，但是文件偏移量为10，那么在进行写操作的时候会直接在10这个位置进行写入，那么5到9这个位置就是空洞，它其实不存在，但是读出来都为默认为0。并且这段区域是不需要分配磁盘块的。也就是0-4有一个磁盘块，10开始有磁盘块，但是5-9没有分配磁盘块。

### 例3.2
![](https://pic.downk.cc/item/5fc636fdf81f7e3bd97f4fc3.png)
运行之后可以得到结果：
![](https://pic.downk.cc/item/5fc6369df81f7e3bd97f387d.png)
函数解释：

```shell
ls -l    //以长格式显示目录下的内容列表
```
![](https://pic.downk.cc/item/5fc636f5f81f7e3bd97f4de2.png)
```shell
ls -l -"filename"   //以长格式显示目录下某个文件的内容列表
```
![](https://pic.downk.cc/item/5fc63669f81f7e3bd97eec47.png)
格式说明
1. 首字母代表的是文件类型，其中"-"为普通文件、"d"为目录文件、"c"为字符设备文件、"b"为块设备文件、"p"为管道文件、"l"为链接文件、"s"为socket文件。
“rwx”分别代表拥有读、写和执行权限，“-”代表无对应权限。三个“rwx”依次代表文件所有者、文件所有者所在用户组、其它用户对文件拥有的权限。
例如我们这里的首字段是-rw-r--r--@，第一个字符是"-"，代表普通文件，接下来是rw-，代表文件所有者对其拥有读写权，但没有执行权。接下来是r--，代表用户所有者所在用户组对其只有读的权利。最后一个是r--，代表其他用户对文件只有读的权利。
2. 第二字段：文件硬连接数量
这里的数量为1，表示只有一个硬连接
3. 第三字段：文件拥有者
文件拥有者是heyizhi
4. 第四字段：文件拥有者所在组
文件拥有者所在组是staff
5. 第五字段：文件大小（以字节为单位）
文件大小，4035
6. 第六字段：文件最后更改时间
文件最后更改时间是4月14日凌晨00:52分
7. 第七字段：文件名（若为链接文件则追加显示其链接的原文件的路径）
文件名是vimrc

**od作用**：按指定格式输出其内容
主要分为以下几种：
| 缩写 | 格式规范 | 说明                                               |
| ---- | -------- | -------------------------------------------------- |
| -a   | -t a     | 输出命名字符                                       |
| -b   | -t o1    | 输出八进制字节                                     |
| -c   | -t c     | 输出可打印的单字节字符，C反斜杠转义或3位八进制序列 |
|-d|	-t u2|	输出无符号十进制数（双字节）
|-f|	-t fF|	输出浮点型。
|-i|	-t dI（大写I）|	输出十进制整数。
|-l|	-t dL|	输出十进制长整型。
|-o|	-t o2|	输出八进制字节（双字节）。
|-s|	-t d2|	输出十进制数（双字节）。
|-x|	-t x2|	输出十六进制数（双字节）。
也就是按照参数的不同以不同的格式输出。若没有参数则直接输出内容：
例如：
```shell
od file.hole
```
输出
![](https://pic.downk.cc/item/5fc63616f81f7e3bd97ed88f.png)
若设置参数则会在每行相应给出地址来输出，同时满足固定的格式：
例如：
```shell
od -c file.hole //意思是输出可打印的单字节字符，以8进制形式
```
![](https://pic.downk.cc/item/5fc636d9f81f7e3bd97f492d.png)


# 7 函数read
函数形式
```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes);
```
如果read成功，返回读到的字节数；如已经到达文件尾端，则返回0.
## 读取到的字节数少于要求读的字节数
1. 读普通文件时，在读到要求字节数之前已经到达了文件尾端。
2. 当从终端设备读时，通常一次最多读一行
3. 当从网络读时，缓冲机制可能导致
4. 从管道或者FIFO读时，如若管道包含的字节少于所需的数量，那么read将只返回实际可用的字节数。
5. 信号中断而已经读了部分数据量时


# 8 函数write
函数形式
```c
#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t nbytes);
```
若成功则返回读到的字节数，若出错，返回-1
**注意：**
其返回值通常与参数nbytes的值相同，否则表示出错。

# 9 I/O效率
## 举例
只使用read和write函数复制一个文件。
![](https://pic.downk.cc/item/5fc63673f81f7e3bd97efa59.jpg)
可以看到。文件的作用是复制所写的内容将其再输出一遍。

# 10 文件共享
UNIX在不同进程间**共享**打开文件。
UNIX内核使用3种数据结构表示打开文件，它们之间的关系决定了在文件共享方面一个进程对另一个进程可能产生的影响。