---
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
title: 8 虚拟机字节码执行引擎  
date: 2022-12-06 10:49:41  
tags: []  
---


# 运行时栈帧结构

每一个方法从调用开始到执行结束的过程，都对应着一个栈帧在虚拟机栈里面从入栈到出栈的过程。

理解：

- 虚拟机栈: 一个程序从 main 方法开始到最终全部执行结束的过程。
- 栈帧: 一个方法从开始到结束的过程。
- main 方法调用的其他方法的数量=栈帧的数量

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221206104617.png" width = "50%" />

可以看到，一个虚拟机栈就是一个 `main` 进程从开始运行到最终结束的过程。在 `main` 进程运行时，每调用一次方法，就会生成一个栈帧，每个方法调用时可能会继续调用其他方法，那么会继续生成栈帧，栈帧的生命周期是和方法同步的。

## 栈帧的组成

- 局部变量表
- 操作数栈
- 动态连接
- 方法返回地址
- 额外的附加信息

### 局部变量表

#### 定义

是一个**数字数组**，主要用于存储**方法参数**和定义在**方法体内的局部变量**，这些数据类型包括各类基本数据类型、对象引用以及 returnAddress 类型。

注意上面加粗的几个点：

1. 数字数组：首先表明局部变量表是一个数组类型，数组内的元素是数组，之所以可以成为数字数组，是因为 8 种基本数据类型，对象引用以及 returnAddress 都可以用数字来进行表示。
2. 方法参数：修饰方法的参数，例如 `private`、`public` 等
3. 方法体内的局部变量：方法体内定义的变量

局部变量表是建立在线程的栈上，因为栈是线程私有的数据，因此**不存在数据安全问题**。

局部变量表所需的**容量大小**是在**编译期确定**下来的，并保存在方法的 Code 属性的 `maximum local variable` 数据项中。在方法运行期间不会改变局部变量表大小。

![image-20221130132906808](https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/image-20221130132906808.png)

可以看到，在最右侧的杂项中，已经得到了局部变量表的最大槽数，为 3，

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/image-20221130133042704.png" width = "50%" />

具体就是 main 方法自带的 args，对象引用类型 test 和自己定义的基本类型 num。

### 操作数栈

直接来看个具体例子：

```java
/**
 * @Author: CoachHe
 * @Date: 2022/11/25 10:00
 */
public class OperandStackTest {
    public void testAddOperation() {
        byte i = 15;
        int j = 0;
        int k = i + j;
    }
}
```

可以看到，是一个很简单的类和方法，那么我们来看看用 `javap -verbose OperandStackTest` 反编译出来的内容：

```txt
Classfile /Users/coachhe/programs/java/jvm-coachhe/Chapter8_JVMBytecodeEngine/target/classes/com/coachhe/section2_运行时栈帧结构/操作数栈/OperandStackTest.class
  Last modified 2022-11-25; size 532 bytes
  MD5 checksum d2ef1ed6453d469857e18d619fc5dd29
  Compiled from "OperandStackTest.java"
public class com.coachhe.section2_运行时栈帧结构.操作数栈.OperandStackTest
  minor version: 0
  major version: 52
  flags: ACC_PUBLIC, ACC_SUPER
Constant pool:
   #1 = Methodref          #3.#19         // java/lang/Object."<init>":()V
   #2 = Class              #20            // com/coachhe/section2_运行时栈帧结构/操作数栈/OperandStackTest
   #3 = Class              #21            // java/lang/Object
   #4 = Utf8               <init>
   #5 = Utf8               ()V
   #6 = Utf8               Code
   #7 = Utf8               LineNumberTable
   #8 = Utf8               LocalVariableTable
   #9 = Utf8               this
  #10 = Utf8               Lcom/coachhe/section2_运行时栈帧结构/操作数栈/OperandStackTest;
  #11 = Utf8               testAddOperation
  #12 = Utf8               i
  #13 = Utf8               B
  #14 = Utf8               j
  #15 = Utf8               I
  #16 = Utf8               k
  #17 = Utf8               SourceFile
  #18 = Utf8               OperandStackTest. java
  #19 = NameAndType        #4:#5          // "<init>":()V
  #20 = Utf8               com/coachhe/section2_运行时栈帧结构/操作数栈/OperandStackTest
  #21 = Utf8               java/lang/Object
{
  public com.coachhe.section2_运行时栈帧结构.操作数栈.OperandStackTest();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=1, locals=1, args_size=1
         0: aload_0
         1: invokespecial #1                  // Method java/lang/Object."<init>":()V
         4: return
      LineNumberTable:
        line 7: 0
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0       5     0  this   Lcom/coachhe/section2_运行时栈帧结构/操作数栈/OperandStackTest;

  public void testAddOperation();
    descriptor: ()V
    flags: ACC_PUBLIC
    Code:
      stack=2, locals=4, args_size=1
         0: bipush        15
         2: istore_1
         3: iconst_0
         4: istore_2
         5: iload_1
         6: iload_2
         7: iadd
         8: istore_3
         9: return
      LineNumberTable:
        line 9: 0
        line 10: 3
        line 11: 5
        line 12: 9
      LocalVariableTable:
        Start  Length  Slot  Name   Signature
            0      10     0  this   Lcom/coachhe/section2_运行时栈帧结构/操作数栈/OperandStackTest;
            3       7     1     i   B
            5       5     2     j   I
            9       1     3     k   I
}
SourceFile: "OperandStackTest. java"
```

可以看到，

```java
         0: bipush        15
         2: istore_1
         3: iconst_0
         4: istore_2
         5: iload_1
         6: iload_2
         7: iadd
         8: istore_3
         9: return
```

这部分对应的是 `testAddOperation()` 方法对应的字节码指令。

### 动态连接

每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的**动态连接**（Dynamic Linking）。

通过 [[6 类文件结构]]的讲解，我们知道 Class 文件的常量池中存有大量的符号引用，字节码中的方法调用指令就以常量池里指向方法的符号引用作为参数。

#### 动态连接和静态解析

- Class 文件中常量池的符号引用的一部分会在类加载阶段或者第一次使用的时候就被转化为直接引用，这种转化被称为静态解析。
- 另外一部分将在每一次运行期间都转化为直接引用，这部分就称为动态连接。

关于这两个转化过程的具体过程，将在接下来会再详细讲解。

### 方法返回地址

退出方法的两种方式

1. 正常调用完成：指的是执行引擎遇到任意一个方法返回的字节码指令
2. 异常调用完成：指的是方法执行得过程中遇到了异常，并且这个异常没有在方法体中得到妥善处理。

无论采用何种退出方式，在方法退出之后，都必须返回到最初方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。

# 方法调用

方法调用并不等同于方法中的代码被执行。方法调用阶段唯一的任务就是**确定被调用方法的版本**（也就是调用哪一个方法），暂时还未涉及方法内部的具体运行过程。

## 1. 解析

Class 文件的编译过程中不包含传统语言编译的连接步骤，一切方法调用在 Class 文件里面存储的都**只是符号引用**，而不是方法在实际运行时内存布局中的入口地址（也就是直接引用）。

而在类加载的**解析阶段**（具体阶段可以看 [[7 虚拟机类加载机制]]），会将其中的一部分符号引用转化为直接引用。

这种解析能够成立的前提是：
方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来，这类方法的调用被称为解析。(来自《深入理解 Java 虚拟机》)

注意：
在这里是有一点歧义的，如果是我理解错了希望大佬可以指出，这里说==这类方法的调用被称为解析==，也就是说 `解析=调用可确定并且在运行期间不可改变的方法版本`，但是在前面的学习中我们知道，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，不单单是这一类方法，还包括很多用 invokedynamic 指令修饰的，在运行期间版本会改变的方法。所以这两个地方对解析的解释是否有歧义呢？

在 Java 语言中，符合==编译器可知，运行期不可变==这个要求的方法，主要有==静态方法==和==私有方法==两大类。

- 静态方法
  与类型直接关联
- 私有方法
  在外部不可被访问

这两种方法各自特点决定了它们不可能通过集成或者别的方式重写出其他版本，因此它们都很适合在类加载阶段进行解析。

### 调用字节码指令的方法

调用不同类型的方法，字节码指令集里设计了不同的指令。在 JVM 中支持以下 5 中方法调用字节码指令：

- invokestatic：用于调用静态方法
- invokespecial：用于调用实例构造器 `<init>()` 方法、私有方法和父类中的方法
- invokevirtual：用于调用所有虚方法
- invokeinterface：用于调用接口方法，会在运行时再确定一个实现接口的对象
- invokedynamic：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

前面四条调用指令，分派逻辑都固化在 JVM 内部，而 invokedynamic 指令的分派逻辑是用户设定的引导方法来决定的。

### 非虚方法和虚方法

只要能被 invokestatic 和 invokespecial，都可以在解析阶段中确定唯一的调用版本。也就是非虚方法，共有以下 5 种

1. 静态方法
2. 私有方法
3. 实例构造器
4. 父类方法
5. 被 final 修饰的方法（虽然它被 invokevirtual 指令调用）
   对于 final 方法，由于历史原因，它是被 invokevirtual 指令调用的，但是因为它也无法被覆盖，没有其他版本的可能，所以它就是一种非虚方法。

以上 5 种方法会在类加载的时候（也就是类周期的第 1 个阶段，详见 [[7 虚拟机类加载机制]]）就可以把符号引用解析为该方法的直接引用。

其他方法被称为虚方法。

代码：方法静态解析演示

```java
package com.coachhe.Chapter3_方法调用;

/**
 * 方法静态解析演示
 *
 * @author coachhe
 */
public class StaticResolution {
    public static void sayHello(){
        System.out.println("Hello World");
    }

    public static void main(String[] args) {
        StaticResolution.sayHello();
    }
}

```

使用 javap 命令查看这段程序对应的字节码：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221212132030.png" width = "50%" />

可以看到，的确是通过 invokestatic 命令来调用 sayHello () 方法，而且其调用的方法版本已经在编译时明确以常量池项的形式固化在字节码指令的参数之中（常量池 #5 号）：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221212131955.png" width = "80%" />

可以看到，和 String 进行了绑定。

## 2. 分派
