---
title: 2. 方法调用  
date: 2022-12-18 17:35:29  
tags: []  
---

方法调用并不等同于方法中的代码被执行。方法调用阶段唯一的任务就是**确定被调用方法的版本**（也就是调用哪一个方法），暂时还未涉及方法内部的具体运行过程。

# 概述

方法调用有两种方式：
1. 解析调用（静态链接）
	**一定是一个静态过程**，在编译期间就完全确定，在类加载的解析阶段就会将设计的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。
2. 分派调用（动态链接）
	**可能是静态的也可能是动态的**，根据分派一局的宗量数可以分为单分派和多分派，具体的会在下面展开。

# 1. 解析

Class 文件的编译过程中不包含传统语言编译的连接步骤，一切方法调用在 Class 文件里面存储的都**只是符号引用**，而不是方法在实际运行时内存布局中的入口地址（也就是直接引用）。

而在类加载的**解析阶段**（具体阶段可以看 [[3. 类加载的过程]]），会将其中的一部分符号引用转化为直接引用。

这种解析能够成立的前提是：
方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来，这类方法的调用被称为解析。(来自《深入理解 Java 虚拟机》)

注意：
在这里是有一点歧义的，如果是我理解错了希望大佬可以指出，这里说==这类方法的调用被称为解析==，也就是说 `解析=调用可确定并且在运行期间不可改变的方法版本`，但是在前面的学习中我们知道，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，不单单是这一类方法，还包括很多用 invokedynamic 指令修饰的，在运行期间版本会改变的方法。所以这两个地方对解析的解释是否有歧义呢？

在 Java 语言中，符合==编译器可知，运行期不可变==这个要求的方法，主要有==静态方法==和==私有方法==两大类。

- 静态方法
  与类型直接关联
- 私有方法
  在外部不可被访问

这两种方法各自特点决定了它们不可能通过集成或者别的方式重写出其他版本，因此它们都很适合在类加载阶段进行解析。

## 调用字节码指令的方法

调用不同类型的方法，字节码指令集里设计了不同的指令。在 JVM 中支持以下 5 中方法调用字节码指令：

- invokestatic：用于调用静态方法
- invokespecial：用于调用实例构造器 `<init>()` 方法、私有方法和父类中的方法
- invokevirtual：用于调用所有虚方法
- invokeinterface：用于调用接口方法，会在运行时再确定一个实现接口的对象
- invokedynamic：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

前面四条调用指令，分派逻辑都固化在 JVM 内部，而 invokedynamic 指令的分派逻辑是用户设定的引导方法来决定的。

## 非虚方法和虚方法

只要能被 invokestatic 和 invokespecial，都可以在解析阶段中确定唯一的调用版本。也就是非虚方法，共有以下 5 种

1. 静态方法
2. 私有方法
3. 实例构造器
4. 父类方法
5. 被 final 修饰的方法（虽然它被 invokevirtual 指令调用）
   对于 final 方法，由于历史原因，它是被 invokevirtual 指令调用的，但是因为它也无法被覆盖，没有其他版本的可能，所以它就是一种非虚方法。

以上 5 种方法会在类加载的时候（也就是类加载的第 1 个阶段，详见 [[3. 类加载的过程]]）就可以把符号引用解析为该方法的直接引用。

其他方法被称为虚方法。

代码：方法静态解析演示

```java
package com.coachhe.Chapter3_方法调用;

/**
 * 方法静态解析演示
 *
 * @author coachhe
 */
public class StaticResolution {
    public static void sayHello(){
        System.out.println("Hello World");
    }

    public static void main(String[] args) {
        StaticResolution.sayHello();
    }
}

```

使用 javap 命令查看这段程序对应的字节码：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221212132030.png" width = "50%" />

可以看到，的确是通过 invokestatic 命令来调用 sayHello () 方法，而且其调用的方法版本已经在编译时明确以常量池项的形式固化在字节码指令的参数之中（常量池 #5 号）：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221212131955.png" width = "80%" />

可以看到，和 String 进行了绑定。

# 2. 分派