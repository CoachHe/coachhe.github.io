---
title: 3. 方法调用  
date: 2022-12-18 17:35:29  
tags: []  
---

方法调用并不等同于方法中的代码被执行。方法调用阶段唯一的任务就是**确定被调用方法的版本**（也就是调用哪一个方法），暂时还未涉及方法内部的具体运行过程。

# 概述

## 方法调用的两种方式

方法调用有两种方式：
1. 解析调用（静态链接、早期绑定）
	**一定是一个静态过程**，在编译期间就完全确定，在类加载的解析阶段就会将设计的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。
2. 分派调用（动态链接、晚期绑定）
	**可能是静态的也可能是动态的**，根据分派一局的宗量数可以分为单分派和多分派，具体的会在下面展开。

```java
/**
 * 说明早期绑定和晚期绑定的例子
 * @author CoachHe
 * @date 2022/12/19 23:50
 **/
public class AnimalTest {
    public void showAnimal(Animal animal) {
        animal.eat(); // 表现为晚期绑定，编译期间无法确认调用哪个方法
    }
    public void showHunt(Huntable huntable) {
        huntable.hunt(); // 表现为晚期绑定，编译期间无法确认调用哪个方法
    }
}
class Animal {
    public void eat(){
        System.out.println("动物进食");
    };
}
interface Huntable {
    void hunt();
}
class Dog extends Animal implements Huntable {
    @Override
    public void eat() {
        System.out.println("狗吃骨头");
    }
    @Override
    public void hunt() {
        System.out.println("捕食耗子，多管闲事");
    }
}
class Cat extends Animal implements Huntable {
    @Override
    public void eat() {
        System.out.println("猫吃鱼");
    }
    @Override
    public void hunt() {
        System.out.println("猫吃耗子，天经地义");
    }
}
```

`AnimalTest` 中的两个方法都表现为晚期绑定。

看看的方法 `showAnimal` 的字节码：

```java
0 aload_1
1 invokevirtual #2 <com/coachhe/section3_方法调用/早期绑定和晚期绑定/Animal.eat : ()V>
4 return
```

再看看方法 `showHunt` 的字节码：

```java
0 aload_1
1 invokeinterface #3 <com/coachhe/section3_方法调用/早期绑定和晚期绑定/Huntable.hunt : ()V> count 1
6 return
```

这两个方法对应的指令 `invokevirtual` 和 `invokeinterface` 都是晚期绑定的指令。

# 1. 解析

Class 文件的编译过程中不包含传统语言编译的连接步骤，一切方法调用在 Class 文件里面存储的都**只是符号引用**，而不是方法在实际运行时内存布局中的入口地址（也就是直接引用）。

而在类加载的**解析阶段**（具体阶段可以看 [[3. 类加载的过程]]），会将其中的一部分符号引用转化为直接引用。

这种解析能够成立的前提是：
方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来，这类方法的调用被称为解析。(来自《深入理解 Java 虚拟机》)

注意：
在这里是有一点歧义的，如果是我理解错了希望可以指出，这里说==这类方法的调用被称为解析==，也就是说 `解析=调用可确定并且在运行期间不可改变的方法版本`，但是在前面的学习中我们知道，解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程，不单单是这一类方法，还包括很多用 invokedynamic 指令修饰的，在运行期间版本会改变的方法。所以这两个地方对解析的解释是否有歧义呢？

回答：
解析分为两种，一种是类加载阶段的解析，这里能成立的前提就是方法在程序真正运行之前就能有一个可确定的调用版本，并且这个方法的调用版本在运行期间是不可改变的。还有一种是运行到 `invodynamic` 指令的解析，这类不是类加载阶段的解析


在 Java 语言中，符合==编译器可知，运行期不可变==这个要求的方法，主要有==静态方法==和==私有方法==两大类。

- 静态方法
  与类型直接关联
- 私有方法
  在外部不可被访问

这两种方法各自特点决定了它们不可能通过集成或者别的方式重写出其他版本，因此它们都很适合在类加载阶段进行解析。

## 调用字节码指令的方法

调用不同类型的方法，字节码指令集里设计了不同的指令。在 JVM 中支持以下 5 中方法调用字节码指令：

- invokestatic：用于调用静态方法
- invokespecial：用于调用实例构造器 `<init>()` 方法、私有方法和父类中的方法
- invokevirtual：用于调用所有虚方法
- invokeinterface：用于调用接口方法，会在运行时再确定一个实现接口的对象
- invokedynamic：现在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

前两条指令和虚方法绑定，后三条指令（除了被 final 修饰的）都是非虚方法

前面四条调用指令，分派逻辑都固化在 JVM 内部，而 invokedynamic 指令的分派逻辑是用户设定的引导方法来决定的。

## 非虚方法和虚方法

只要能被 invokestatic 和 invokespecial，都可以在解析阶段中确定唯一的调用版本。也就是非虚方法，共有以下 5 种

1. 静态方法
2. 私有方法
3. 实例构造器
4. 父类方法
5. 被 final 修饰的方法（虽然它被 invokevirtual 指令调用）
   对于 final 方法，由于历史原因，它是被 invokevirtual 指令调用的，但是因为它也无法被覆盖，没有其他版本的可能，所以它就是一种非虚方法。

以上 5 种方法会在类加载的时候（也就是类加载的第 1 个阶段，详见 [[3. 类加载的过程]]）就可以把符号引用解析为该方法的直接引用。

其他方法被称为虚方法。

代码：方法静态解析演示

```java
package com.coachhe.Chapter3_方法调用;

/**
 * 方法静态解析演示
 *
 * @author coachhe
 */
public class StaticResolution {
    public static void sayHello(){
        System.out.println("Hello World");
    }

    public static void main(String[] args) {
        StaticResolution.sayHello();
    }
}

```

使用 javap 命令查看这段程序对应的字节码：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221212132030.png" width = "50%" />

可以看到，的确是通过 invokestatic 命令来调用 `sayHello()` 方法，而且其调用的方法版本已经在编译时明确以常量池项的形式固化在字节码指令的参数之中（常量池 `#5` 号）：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221212131955.png" width = "80%" />

可以看到，和 String 进行了绑定。

更加具体的，我们来看下面这段代码：

```java
/**
 * @author CoachHe
 * @date 2022/12/20 00:50
 **/
public class Son extends Father{
    public Son() {
        super();
    }

    public Son(int age) {
        this();
    }

    // 不是重写父类方法，因为静态方法不能被重写
    public static void showStatic(String str) {
        System.out.println("son " + str);
    }

    private void showPrivate(String str) {
        System.out.println("son private" + str);
    }

    public void show(){
        showStatic("coachhe.github.io"); // 自身的showStatic
        super.showStatic("good"); // 父类的showStatic
        showPrivate("hello"); // 自身的private方法
        super.showCommon(); // 父类的Common方法
        showFinal();

        showCommon();
        info();

        MethodInterface in = null;
        in.methodA();
    }

    public void info(){}
}

class Father {
    public Father() {
        System.out.println("father的构造器");
    }

    public static void showStatic(String str) {
        System.out.println("father " + str);
    }

    public final void showFinal() {
        System.out.println("father show final");
    }

    public void showCommon() {
        System.out.println("father 普通方法");
    }
}

interface MethodInterface{
    void methodA();
}

```

可以先看看子类的 `show()` 方法中的前五个

```java
showStatic("coachhe.github.io"); // 自身的showStatic
super.showStatic("good"); // 父类的showStatic
showPrivate("hello"); // 自身的private方法
super.showCommon(); // 父类的Common方法
showFinal();
```

看看对应的字节码：

```java
 0 ldc #11 <coachhe.github.io>
 2 invokestatic #12 <com/coachhe/section3_方法调用/虚方法和非虚方法/Son.showStatic : (Ljava/lang/String;)V>
 5 ldc #13 <good>
 7 invokestatic #14 <com/coachhe/section3_方法调用/虚方法和非虚方法/Father.showStatic : (Ljava/lang/String;)V>
10 aload_0
11 ldc #15 <hello>
13 invokespecial #16 <com/coachhe/section3_方法调用/虚方法和非虚方法/Son.showPrivate : (Ljava/lang/String;)V>
16 aload_0
17 invokespecial #17 <com/coachhe/section3_方法调用/虚方法和非虚方法/Father.showCommon : ()V>
20 aload_0
21 invokevirtual #18 <com/coachhe/section3_方法调用/虚方法和非虚方法/Son.showFinal : ()V>
```

可以看到，这里除了调用被 final 修饰的方法，都采用的是非虚方法的字节码。

final 方法被 `invokevirtual` 调用，但是也是非虚方法

那么几个特殊的我们可以看下：

```java
super.showCommon();
showCommon();
```

可以看到，这里一个是调用了父类的 `showCommon` 方法，因为方法是确认的（也就是编译器可以明确你到底是调用了哪个方法），因此这里是 `invokespecial`。

但是对于 `showCommon()`，因为随时有可能被子类重写，因此无法确认调用的具体是哪个，因此是采用了 `invokevirtual` 。

我们来验证一下，看字节码：

```java
17 invokespecial #17 <com/coachhe/section3_方法调用/虚方法和非虚方法/Father.showCommon : ()V>
20 aload_0
25 invokevirtual #19 <com/coachhe/section3_方法调用/虚方法和非虚方法/Son.showCommon : ()V>
28 aload_0
```

可以看到，和我们推断是相同的。

再看看:

```java
MethodInterface in = null;
in.methodA();
```

可以看到，采用了 `invokeinterface` ，因为接口是必须要重写的。

```java
35 invokeinterface #21 <com/coachhe/section3_方法调用/虚方法和非虚方法/MethodInterface.methodA : ()V> count 1
```






# 2. 分派

## 静态分派

为了解释静态分派和重载（Overloading），这里准备了一段程序代码

```java
/**
 * Created with IntelliJ IDEA.
 * User: coachhe
 * Date: 2022/12/13
 * Time: 16:17
 * Description: 方法静态分派演示
 */
public class StaticDispatch {

    static abstract class Human {}

    static class Man extends Human {}

    static class Woman extends Human {}

    public void sayHello(Human guy) {
        System.out.println("Hello, guy");
    }

    public void sayHello(Man guy) {
        System.out.println("Hello, gentleman");
    }

    public void sayHello(Woman guy) {
        System.out.println("Hello, lady");
    }

    public static void main(String[] args) {
        Human man = new Man();
        Human woman = new Woman();
        StaticDispatch sr = new StaticDispatch();
        sr.sayHello(man); // Hello, guy
        sr.sayHello(woman); // Hello, guy
    }


}

```

可以看到，这里输出的两条都是 `Hello, guy`，这是怎么回事呢？ 为什么通过

```java
Human man = new Man();
```

出来的 `man` 对象调用 `sayHello()` 方法时出现的是 `Hello, guy` 而不是 `Hello, gentlement` 呢？

这是因为，我们把上面代码中的“Human”称为变量的**静态类型**（Static Type），或者叫**外观类型**（Apparent Type），后面的“Man”则被称为变量的**实际类型**（Actual Type）或者叫“运行时类型”（Runtime Type）。

静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。

在方法接收者已经确定是对象“sr”的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。代码中故意定义了两个静态类型相同，而实际类型不同的变量，但虚拟机（或者准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。由于静态类型在编译期可知，所以在编译阶段，Javac 编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了 `sayHello(Human)` 作为调用目标，并把这个方法的符号引用写到 `main()` 方法里的两条 `invokevirtual` 指令的参数中。

也就是说，在编译期间就确定了调用方法的版本。

### 静态分派定义

所有以来静态类型来决定方法执行版本的分派动作，都称为静态分派。

静态分配的**最典型应用表现就是方法重载**。关于方法重载的更详细内容可以看 [[2. 方法重载]]

## 动态分派

来看一段代码：

```java
/**  
 * @author CoachHe  
 * @date 2022/12/28 02:49  
 * 动态分派延时  
 **/  
public class DynamicDispatch {  
    static abstract class Human {  
        protected abstract void sayHello();  
    }  
  
    static class Man extends Human {  
        @Override  
        protected void sayHello() {  
            System.out.println("man say hello");  
        }  
    }  
  
    static class Woman extends Human {  
        @Override  
        protected void sayHello() {  
            System.out.println("woman say hello");  
        }  
    }  
  
    public static void main(String[] args) {  
        Human man = new Man();  
        Human woman = new Woman();  
        man.sayHello(); // man say hello  
        woman.sayHello(); // woman say hello  
        man = new Woman();  
        man.sayHello(); // woman say hello  
    }  
}
```

这个结果没什么好说的，但是，Java 虚拟机是如何判断应该调用哪个方法呢？

显然这里和上面静态分派中说的方法重载是完全不同的，也就是说这里选择的方法版本是不可能再根据静态类型来决定的，因为静态类型都是 `Human` 的两个变量 `man` 和 `woman` 在调用 `sayHello()` 方法时产生了不同的行为，甚至变量 `man` 在两次调用中还执行了两个不同的方法。

导致这个现象的原因很明显，是因为这两个变量的实际类型不同。那么我们来具体看下字节码。

```java
 0 new #2 <com/coachhe/section3_方法调用/S2_分派/DynamicDispatch$Man>
 3 dup
 4 invokespecial #3 <com/coachhe/section3_方法调用/S2_分派/DynamicDispatch$Man.<init> : ()V>
 7 astore_1
 8 new #4 <com/coachhe/section3_方法调用/S2_分派/DynamicDispatch$Woman>
11 dup
12 invokespecial #5 <com/coachhe/section3_方法调用/S2_分派/DynamicDispatch$Woman.<init> : ()V>
15 astore_2
16 aload_1
17 invokevirtual #6 <com/coachhe/section3_方法调用/S2_分派/DynamicDispatch$Human.sayHello : ()V>
20 aload_2
21 invokevirtual #6 <com/coachhe/section3_方法调用/S2_分派/DynamicDispatch$Human.sayHello : ()V>
24 new #4 <com/coachhe/section3_方法调用/S2_分派/DynamicDispatch$Woman>
27 dup
28 invokespecial #5 <com/coachhe/section3_方法调用/S2_分派/DynamicDispatch$Woman.<init> : ()V>
31 astore_1
32 aload_1
33 invokevirtual #6 <com/coachhe/section3_方法调用/S2_分派/DynamicDispatch$Human.sayHello : ()V>
36 return
```

0-15 行的字节码是准备动作，具体的详情可以参考[[补充-String和字符串常量池]]，基本作用是建立 `man` 和 `woman` 的内存空间、调用 `Man` 和 `Woman` 类型的实际构造器，将这两个实例的引用存在在第 1、2 个局部变量表的变量槽里，这些动作实际对应了这两行：

```java
        Human man = new Man();  
        Human woman = new Woman();  
```

接下来 16-21 行是关键，16 行和 20 行的 `aload_1` 和 `aload_2` 分别是将刚刚创建的两个对象的引用压到栈顶，这两个对象是要执行的 `sayHello()` 方法的所有者，具体的执行行是第 17 和第 21 行，但是他们都是：

```java
21 invokevirtual #6 <com/coachhe/section3_方法调用/S2_分派/DynamicDispatch$Human.sayHello : ()V>
```

也就是说，他们无论是指令还是参数都完全一样，但是这两句指令最终执行的目标方法并不相通。那看来解决问题的关键还是必须从 `invokevirtual` 指令本身入手。

### invokevirtual 指令

`invokevirtual` 指令的运行时解析过程大致分为y

