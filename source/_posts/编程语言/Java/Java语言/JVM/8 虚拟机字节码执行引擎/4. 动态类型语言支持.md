---
title: 4. 动态类型语言支持
tags: []
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
  - 8 虚拟机字节码执行引擎
date: 2022-12-20 01:17:49
---

# 1. 动态类型语言

## 动态类型语言定义

何谓动态类型语言？动态类型语言的关键特征是它的**类型检查的主体过程是在运行期**而不是编译器进行的。

## 运行时异常和连接时异常

所谓运行时异常，就是指只要代码不执行到这一行就不会出问题。

所谓连接时异常，与运行时异常相对应。例如很常见的 NoClassDefFoundError 便属于连接时异常，即使连接时异常的代码放在一条根本无法被执行到的路径分支上，类加载时也照样会抛出异常。

# 2. Java 与动态类型

现在我们回到本节的主题，来看看 Java 语言、Java 虚拟机与动态类型语言之间有什么关系。

Java 虚拟机毫无疑问是 Java 语言的运行平台，但它的使命并不限于此，早在 1997 年出版的《Java 虚拟机规范》第 1 版中就规划了这样一个愿景：“在未来，我们会对 Java 虚拟机进行适当的扩展，以便更好地支持其他语言运行于 Java 虚拟机之上。”而目前确实已经有许多动态类型语言运行于 Java 虚拟机之上了，如 Clojure、Groovy、Jython 和 JRuby 等，能够在同一个虚拟机之上可以实现静态类型语言的严谨与动态类型语言的灵活，这的确是一件很美妙的事情。

但遗憾的是 Java 虚拟机层面对动态类型语言的支持一直都还有所欠缺

## Java 在面对动态类型语言的支持欠缺

主要表现在**方法调用**方面：

JDK 7 以前的字节码指令集中，4 条方法调用指令（invokevirtual、invokespecial、invokestatic、 invokeinterface）的第一个参数都是被调用的方法的符号引用（CONSTANT_Methodref_info 或者 CONSTANT_InterfaceMethodref_info 常量）

前面已经提到过，方法的符号引用在编译时产生，而动态类型语言只有在运行期才能确定方法的接收者。这样，在 Java 虚拟机上实现的动态类型语言就不得不使用“曲线救国”的方式（如编译时留个占位符类型，运行时动态生成字节码实现具体类型到占位符类型的适配）来实现，但这样势必会让动态类型语言实现的复杂度增加，也会带来额外的性能和内存开销。内存开销是很显而易见的，方法调用产生的那一大堆的动态类就摆在那里。而其中最严重的性能瓶颈是在于动态类型方法调用时，由于无法确定调用对象的静态类型，而导致的方法内联无法有效进行。在第 11 章里我们会讲到方法内联的重要性，它是其他优化措施的基础，也可以说是最重要的一项优化。尽管也可以想一些办法（譬如调用点缓存）尽量缓解支持动态语言而导致的性能下降，但这种改善毕竟不是本质的。譬如有类似以下代码：

```java
var arrays = {"abc", new ObjectX (), 123, Dog, Cat, Car..} 
for (item in arrays) { 
    item.sayHello(); 
}
```

在动态类型语言下这样的代码是没有问题，但由于在运行时 arrays 中的元素可以是任意类型，即使它们的类型中都有 `sayHello()` 方法，也肯定无法在编译优化的时候就确定具体 `sayHello()` 的代码在哪里，编译器只能不停编译它所遇见的每一个 `sayHello()` 方法，并缓存起来供执行时选择、调用和内联，如果 arrays 数组中不同类型的对象很多，就势必会对内联缓存产生很大的压力，缓存的大小总是有限的，类型信息的不确定性导致了缓存内容不断被失效和更新，先前优化过的方法也可能被不断替换而无法重复使用。所以这种动态类型方法调用的底层问题终归是应当在 Java 虚拟机层次上去解决才最合适。因此，在 Java 虚拟机层面上提供动态类型的直接支持就成为 Java 平台发展必须解决的问题，这便是 JDK 7 时 JSR-292 提案中 invokedynamic 指令以及 `java.lang.invoke` 包出现的技术背景

# 3. `java.lang.invoke 包