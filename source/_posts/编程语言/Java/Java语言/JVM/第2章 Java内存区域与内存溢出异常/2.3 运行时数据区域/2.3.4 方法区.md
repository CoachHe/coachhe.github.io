---
title: 2.3.4 方法区
tags: []
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
  - 第2章 Java内存区域与内存溢出异常
  - 2.3 运行时数据区域
date: 2022-12-29 15:53:32
---

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20230102145808.png" width = "80%" />

# 栈、堆和方法区的交互关系


我们来看两张图：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20230102233052.png" width = "50%" />


<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20230102233012.png" width = "80%" />

# 方法区的位置

尽管所有方法区在逻辑上是属于堆的一部分，但一些简单的实现可能不会选择去进行垃圾收集或者进行压缩。

但对于 HotSpot JVM 而言，方法区还有一个别名叫做 Non-Heap (非堆)，目的就是要和堆分开。

所以，方法区可以看做是一块独立于 Java 堆的内存空间。

# 方法区的基本理解

- 方法区与 Java 堆一样，是各个线程共享的内存区域
- 方法区在 JVM 启动时被创建，并且它的实际物理内存空间中和 Java 堆区一样都可以是不连续的
- 方法区的大小，和堆空间一样，可以选择固定大小或者可拓展
- 方法区的大小决定了系统可以保存多少类，如果系统定义了太多类，导致方法区溢出，虚拟机同样会抛出内存溢出错误
- 关闭 JVM 就会释放这个区域的内存

# 方法区的演进

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20230102234944.png" width = "80%" />

# 方法区中存储的信息

方法区用于存储已被虚拟机加载的:

- 类型信息
- 常量
- 静态变量
- 即时编译器编译后的代码缓存等。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20230102235710.png" width = "80%" />

注意，最后两个箭头（域信息和方法信息）是包含在类型信息里的。

## 类型信息

对每个加载的类型（类 class、接口 interface、枚举 enum、注解 annotation），JVM 必须在方法区中存储一下类型信息：

- 这个类型的完整有效名称（全名=包名. 类名）
- 这个类型直接父类的完整有效全名（对于 interface 或是 `java.lang.Object`，都没有父类）
- 这个类型的修饰符（public、abstract、final 的某个子集）
- 这个类型直接接口的一个有序列表

## 域信息

- JVM 必须在方法区中保存类型的所有域的相关信息以及域的声明顺序
- 域的相关信息包括：
	- 域名称
	- 域类型
	- 域修饰符（public、private、protected、static、final、volatile、transient 的某个子集）

## 方法信息

- 方法名称
- 方法返回类型（void）
- 方法参数的数量和类型（按顺序）
- 方法的修饰符（public、private、protected、static、final、volatile、transient 的某个子集）
- 方法的字节码（bytecodes）、操作数栈、局部变量表及大小（abstract 和 native 方法除外）
- 异常表（abstract 和 native 方法除外）
	- 每个异常处理的开始位置、结束位置、代码处理在程序计数器中的偏移地址、被捕获的异常类的常量池索引

## non-final 的类变量

- 静态变量和类关联在一起，随着类的加载而加载，它们成为类数据在逻辑上的一部分。
- 类变量被类的所有实例共享，即使没有类实例也可以访问




