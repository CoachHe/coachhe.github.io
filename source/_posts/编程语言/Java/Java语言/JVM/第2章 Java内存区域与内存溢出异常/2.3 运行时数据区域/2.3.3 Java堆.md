---
title: 2.3.3 Java堆
tags: []
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
  - 第2章 Java内存区域与内存溢出异常
  - 2.3 运行时数据区域
date: 2022-12-29 15:53:35
---

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221229204642.png" width = "60%" />

在这里做一个小总结。

- 一个 Java 程序对应一个进程
- 一个进程对应一个 jvm 实例
- 一个 jvm 实例中只有一个运行时数据区
- 一个运行时数据区只有一个方法区和堆
- 一个进程中的多个线程需要共享同一个方法区，堆空间
- 每一个线程拥有独立的一套程序计数器，本地方法栈和虚拟机栈

# 核心概述

Java 堆区在 **JVM 启动的时候**即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存。

此内存区域的**唯一目的**就是存放对象实例了，Java 世界里**几乎**所有对象实例都在这里分配内存。注意: 这里的几乎是因为随着编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说 Java 对象实例都分配在堆上也渐渐变得不是那么绝对了。

- 堆内存的大小是可以调节的

堆可以处于物理上不连续的内存空间中，但在逻辑上它应该被视为连续的。

所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（TLAB）

## 每个进程都有一个堆空间

这里我们来证明一下，首先我们写两个程序，里面内容是相同的：

```java
/**
 * @author CoachHe
 * @date 2022/12/30 00:45
 **/
public class HeapDemo {
    public static void main(String[] args) {
        System.out.println("start...");
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("end...");
    }
}

/**
 * @author CoachHe
 * @date 2022/12/30 00:45
 **/
public class HeapDemo1 {
    public static void main(String[] args) {
        System.out.println("start...");
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("end...");
    }
}

```


