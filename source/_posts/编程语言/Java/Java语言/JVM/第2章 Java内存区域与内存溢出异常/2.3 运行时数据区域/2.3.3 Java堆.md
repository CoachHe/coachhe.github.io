---
title: 2.3.3 Java堆
tags: []
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
  - 第2章 Java内存区域与内存溢出异常
  - 2.3 运行时数据区域
date: 2022-12-29 15:53:35
---

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221229204642.png" width = "60%" />

在这里做一个小总结。

- 一个 Java 程序对应一个进程
- 一个进程对应一个 jvm 实例
- 一个 jvm 实例中只有一个运行时数据区
- 一个运行时数据区只有一个方法区和堆
- 一个进程中的多个线程需要共享同一个方法区，堆空间
- 每一个线程拥有独立的一套程序计数器，本地方法栈和虚拟机栈

# 核心概述

- Java 堆区在 **JVM 启动的时候**即被创建，其空间大小也就确定了。是 JVM 管理的最大一块内存。
- 此内存区域的**唯一目的**就是存放对象实例了，Java 世界里**几乎**所有对象实例都在这里分配内存。注意: 这里的几乎是因为随着编译技术的进步，尤其是逃逸分析技术的日渐强大，栈上分配、标量替换优化手段已经导致一些微妙的变化悄然发生，所以说 Java 对象实例都分配在堆上也渐渐变得不是那么绝对了。
- 堆内存的大小是可以调节的
- 堆可以处于**物理上不连续**的内存空间中，但在**逻辑上**它应该被视为**连续**的。
- 所有的线程共享 Java 堆，在这里还可以划分线程私有的缓冲区（TLAB）。注意：因此，堆空间并不是完全共享的（目的是解决堆的并发性太低的问题）
- 在方法结束后，堆中的对象不会马上被移除，仅仅在**垃圾收集的时候才会被移除**。
- 堆，是 GC 执行垃圾回收的重点区域

这里我们来证明一下堆空间大小参数设置的效果以及堆空间与线程的统一性，也就是说，堆空间是和线程绑定的，每个 JVM 线程对应一个堆空间

首先我们写两个程序，里面内容是相同的，但是 VM 参数不同

```java
/**
 * @author CoachHe
 * @date 2022/12/30 00:45
 * VM 参数：-Xms10m -Xmx10m
 **/
public class HeapDemo {
    public static void main(String[] args) {
        System.out.println("start...");
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("end...");
    }
}

/**
 * @author CoachHe
 * @date 2022/12/30 00:45
 * VM 参数：-Xms20m -Xmx20m
 **/
public class HeapDemo1 {
    public static void main(String[] args) {
        System.out.println("start...");
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        System.out.println("end...");
    }
}

```

这里 `Thread.sleep(1000000)` 是为了让程序不马上结束，我们能查看到具体细节，并且这里 VM 参数是不同的，一个设置为了 10M 堆空间，一个设置为了 20M 堆空间。

运行起来之后我们打开程序 VisualVM，来看下效果：

首先是 HeapDemo，这里我们设置的是 10M 堆空间，可以看到 Eden Space + Survivor 0 区 + Survivor 1 区 + Old Gen 的空间之和就是 10M。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221230011817.png" width = "80%" />

注意，这里是没有包括方法区的，关于方法区的具体解释可以看下一章 [[2.3.4 方法区]]

HeapDemo1 同理，这里是 20M：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221230011959.png" width = "80%" />

并且这两个进程是完全独立的，也证明了两个进程的堆空间是完全独立的。

# 堆的内存细分

现代垃圾收集器大部分都基于分代收集理论设计，堆空间细分为：

## JDK7 及之前的堆内存

**逻辑上**主要分为三部分：新生区+养老区+永久区

- Young Generation Space 新生区/新生代/年轻代 Young/New
	其中新生区又被分为 Eden 区和 Survivor 区
 - Tenure Generation Space 养老区/老年区/老年代 Old/Tenure
 - Permanent Space 永久区/永久代 Perm

## JDK8 及之后的堆内存

**逻辑上**分为三部分：新生区+养老区+元空间

- Young Generation Space 新生区/新生代/年轻代 Young/New
	其中新生区又被分为 Eden 区和 Survivor 区
 - Tenure Generation Space 养老区/老年区/老年代 Old/Tenure
 - Meta Space 元空间 Meta

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221230014806.png" width = "70%" />

我们来看一个程序：

```java
/**
 * @author CoachHe
 * @date 2022/12/30 01:52
 * VM 参数：
 * -Xms10m -Xmx10m -XX:+PrintGCDetails
 * 目的是为了查看堆内存的结构，运行之后查看输出
 **/
public class SimpleHeap {
    private int id;//属性，成员变量

    public SimpleHeap(int id) {
        this.id = id;
    }

    public void show() {
        System.out.println("My ID is " + id);
    }

    public static void main(String[] args) {
        SimpleHeap s1 = new SimpleHeap(1);
        SimpleHeap s2 = new SimpleHeap(2);
    }
}
```

它的 VM 参数是：

```java
-Xms10m -Xmx10m -XX:+PrintGCDetails
```

这个程序的目的是为了查看堆内存的结果，将其运行，输出为：

```java
Heap
 PSYoungGen      total 2560K, used 1521K [0x00000007ffd00000, 0x0000000800000000, 0x0000000800000000)
  eden space 2048K, 74% used [0x00000007ffd00000,0x00000007ffe7c7a0,0x00000007fff00000)
  from space 512K, 0% used [0x00000007fff80000,0x00000007fff80000,0x0000000800000000)
  to   space 512K, 0% used [0x00000007fff00000,0x00000007fff00000,0x00000007fff80000)
 ParOldGen       total 7168K, used 0K [0x00000007ff600000, 0x00000007ffd00000, 0x00000007ffd00000)
  object space 7168K, 0% used [0x00000007ff600000,0x00000007ff600000,0x00000007ffd00000)
 Metaspace       used 3132K, capacity 4496K, committed 4864K, reserved 1056768K
  class space    used 333K, capacity 388K, committed 512K, reserved 1048576K
```

注意，这里用 jdk8 比较有效果，用 jdk11 输出的看没啥用

可以看到，堆空间分为新生代，老年代和元空间，其中新生代+老年代就是 10M，等于堆空间的大小。并且这里方法区为元空间。

注意，如果将 jdk 版本改为 jdk7 或之前，这里的元空间会变成 PermSpace，也就是永久代。


# 堆空间大小设置

设置堆空间大小一共有两个参数：
- `-Xms10M` 设置堆空间起始内存为 10M，等价于 `-XX:InitialHeapSize`
- `-Xmx10M` 设置堆空间最大为 10M，等价于 `-XX:MaxHeapSize`

### 默认内存大小

默认情况下
- 初始内存大小 = 物理电脑内存大小 / 64
- 最大内存大小 = 物理电脑内存大小 / 4

## 默认内存大小查看

我们写一段程序来查看电脑默认内存大小：

```java
/**
 * @author CoachHe
 * @date 2022/12/30 02:11
 * 查看堆内存的初始大小以及堆内存大小设置
 * 设置堆空间大小一共有两个参数：
 * - `-Xms10M` 设置堆空间起始内存为 10M，等价于 `-XX:InitialHeapSize`
 * - `-Xmx10M` 设置堆空间最大为 10M，等价于 `-XX:MaxHeapSize`
 * 默认内存大小:
 * - 初始内存大小 = 物理电脑内存大小 / 64
 * - 最大内存大小 = 物理电脑内存大小 / 4
 *
 **/
public class HeapSpaceInitial {
    public static void main(String[] args) {
        // 返回Java虚拟机中堆内存总量
        long initialMemory = Runtime.getRuntime().totalMemory() / 1024 / 1024;
        // 返回Java虚拟机视图使用的最大堆内存量
        long maxMemory = Runtime.getRuntime().maxMemory() / 1024 / 1024;

        System.out.println("-Xms : " + initialMemory + "M");
        System.out.println("-Xmx : " + maxMemory + "M");

        System.out.println("系统内存大小为： " + initialMemory * 64.0 / 1024 + "G");
        System.out.println("系统内存大小为： " + maxMemory * 4.0 / 1024 + "G");
    }
}
```

### Macos 系统执行

第一次我们不填写任务参数进行运行，看下输出：

```txt
-Xms : 256M
-Xmx : 4096M
系统内存大小为： 16.0G
系统内存大小为： 16.0G
```

可以看到，和我电脑主机情况是完全相同的。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221230021720.png" width = "50%" />

第二次我们填写参数：

```java
-Xms600M -Xmx600M
```

此时我们会看到以下输出：

```txt
-Xms : 600M
-Xmx : 600M
系统内存大小为： 37.5G
系统内存大小为： 2.34375G
```

这个显然是和我们系统不相匹配的，因为这里是我们手动设置的。

有一个需要注意的： 
**在开发中建议将初始堆内存和最大堆内存设置成相同值**，原因是避免堆空间不断扩容，一开始直接设置堆空间大小可以避免在程序运行过程中堆空间不足而不断进行的扩容操作。

### Windows 系统执行

第一次我们不填写任何 VM 参数，看输出：

```txt
-Xms : 489M
-Xmx : 7246M
系统内存大小为： 30.5625G
系统内存大小为： 28.3046875G
```

可以看到，和我的 windows 电脑情况也是相同的：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221230110245.png" width = "50%" />

第二次我们填写入 VM 参数：

```java
-Xms600M -Xmx600M
```

来看输出：

```txt
-Xms : 575M
-Xmx : 575M
系统内存大小为： 35.9375G
系统内存大小为： 2.24609375G
```

可以看到，在有参数输入的情况下，我们可以看到无论是 MACOS 系统还是 WINDOWS 系统都有相同的输出。

## 年轻代和老年代

存储在 JVM 中的 Java 对象可以分为两类
- 生命周期较短的瞬时对象，这类对象的创建和消亡都非常迅速
- 生命周期非常长，在某些极端情况下能够与 JVM 的生命周期保持一致

因此，生命周期短的放在年轻代，可以经常进行 GC，生命周期长的放在老年代，较为稳定。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221230131314.png" width = "50%" />

### 调整年轻代和老年代的大小

- 默认 `-XX:NewRatio=2`，表示新生代占 1，老年代占 2
- 可以修改 `-XX:NewRatio=4`，表示新生代占 1，老年代占 4

在 HotSpot 中，Eden 空间和另外两个 Survivor 空间缺省所占比例是 `8:1:1`。

开发人员可以通过 `-XX:SurvivorRatio` 调整这个空间比例。

注意，绝大部分的 Java 对象的销毁都在新生代进行（80%）

可以使用 `-Xmn` 设置新生代的空间大小（一般不设置）

# 图解对象分配的一般过程

主要分为三种形式：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221231141144.png" width = "70%" />

这是第一种情况，当 S0 和 S1 区都是空的时候，若 Eden 区已满，则会进行一次 Young GC，将 Eden 区中的垃圾清理，存活的对象移动到 S0 或者 S1 区，并且垃圾的引用计数器会加 1。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221231141333.png" width = "70%" />

这是第二种情况，当 S0 或 S1 不为空时（这两个不可能同时不为空，我们称不空的为 From 区，为空的为 To 区），若 Eden 区已满，则会进行一个 Young GC，将 Eden 中的垃圾清理，存活的对象和 From 区中的对象一起移动到 To 区。

需要注意的是，进行 Young GC 时，From 区中的对象也会进行检查，为空的也会被清理。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221231141741.png" width = "70%" />

这是第三种情况，当 From 区中有元素的ji'shu'q



