---
title: 4 对象探秘
tags: []
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
  - 第2章 Java内存区域与内存溢出异常
  - 2.4 对象探秘
date: 2022-12-19 11:01:02
---

# 对象探秘

## 1. 对象的创建

### 1. 类的加载

先看看《深入理解JVM》里面的步骤：

当Java虚拟机遇到一条字节码new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。

这部分对应的内容就是`java.lang.ClassLoader`类的`loadClass`方法。

首先，来看看前半句话： 
**当 Java 虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过**

对应的源码部分：

<img src= https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20210810094227.png width="50%"> 

点进`findLoadClass(name)`，可以看到：

<img src= https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20210810094452.png width="50%">

在这里，`checkName`很简单，作用是检查name是否为null或者是一个有效的二进制名，然后根据`findLoadedClass0`这个native方法去执行JVM的方法。

接下来看看后半句话：

**如果没有，那必须先执行相应的类加载过程。**

对应的源码部分：

<img src= https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20210810114433.png width="50%">

这部分内容在[[3. 类加载的过程]]进行详细说明，我们先大概分析一下，就是首先使用双亲委派机制尝试进行类的加载，如果失败，那么需要调用findClass方法来进行类的加载，最终返回的是一个Class对象。
总结一下：类的加载主要分为三个步骤

1.  检查是否已经加载，有就直接返回，避免重复加载
2.  当前缓存中确实没有该类，那么遵循父优先加载机制，加载.class文件
3.  上面两步都失败了，调用findClass()方法加载




2. 分配内存
同样，看看《深入理解 JVM》
在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从 Java 堆中划分出来。

