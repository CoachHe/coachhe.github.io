---
title: 2.4.1 对象的创建
tags: []
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
  - 第2章 Java内存区域与内存溢出异常
  - 2.4 对象探秘
date: 2022-12-19 11:01:02
---

# 总论

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20230105234518.png" width = "100%" />

下面来具体展开阐述上面的图

# 创建对象的方式

创建对象一共有 6 种方式，分别是：

- 使用 new 关键字来创建，这是最常用的
	- 变形 1：Xxx 的静态方法
	- 变形 2：Xxx Builder/Factory
- Class 的 `newInstance()` : 反射的方式，只能调用空参构造器，权限必须是 public
- Constructor 的 `newInstance(Xxx)` : 反射的方式，可以调用无参或者有参构造器，权限不需要是 public
- 使用 `clone()`
- 使用反序列化
- 第三方库 `Objenesis`

接下来我们来描述一下使用 `new` 关键字创建一个对象所经历的步骤

# 创建对象的步骤

## 1. 类的加载

先看看《深入理解JVM》里面的步骤：

当 Java 虚拟机遇到一条字节码 new 指令时，首先

1. 检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。
2. 如果没有，那必须先执行相应的类加载过程。

这部分对应的内容就是`java.lang.ClassLoader`类的`loadClass`方法。

首先，来看看前半句话： 
**当 Java 虚拟机遇到一条字节码 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过**

对应的源码部分：

<img src= https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20210810094227.png width="50%"> 

点进`findLoadClass(name)`，可以看到：

<img src= https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20210810094452.png width="50%">

在这里，`checkName`很简单，作用是检查name是否为null或者是一个有效的二进制名，然后根据`findLoadedClass0`这个native方法去执行JVM的方法。

接下来看看后半句话：

**如果没有，那必须先执行相应的类加载过程。**

对应的源码部分：

<img src= https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20210810114433.png width="50%">

这部分内容在 [[7.3 类加载的过程]] 进行详细说明，我们先大概分析一下，就是首先使用双亲委派机制尝试进行类的加载，如果失败，那么需要调用 `findClass()` 方法来进行类的加载，最终返回的是一个 Class 对象。

总结一下：类的加载主要分为三个步骤

1.  检查是否已经加载，有就直接返回，避免重复加载
2.  当前缓存中确实没有该类，那么遵循父优先加载机制，加载.class文件
3.  上面两步都失败了，调用findClass()方法加载

## 2. 分配内存

同样，看看《深入理解 JVM》

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务实际上便等同于把一块确定大小的内存块从 Java 堆中划分出来。

在进行内存分配的时候，内存有两种情况：

- 如果**内存规整**：指针碰撞（意思是所有用过的内存放在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，分配内存就仅仅是把指针向空闲那边挪动一段与对象大小相等的距离罢了。如果垃圾收集器选择的是 Serial、ParNew 这种基于压缩算法的，虚拟机采用这种分配方式。一般使用带有 compact 也就是整理过程的收集器时，使用指针碰撞）
- 如果**内存不规整**：虚拟机需要维护一个列表，空闲列表分配（如果内存是不规整的，已使用的内存和未使用的内存相互交错，那么虚拟机将采用的是空闲列表法来为对象分配内存。意思是虚拟机维护了一个列表，记录哪些内存块是可用的，再分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的内容。这种分配方式称为“空闲列表”）

