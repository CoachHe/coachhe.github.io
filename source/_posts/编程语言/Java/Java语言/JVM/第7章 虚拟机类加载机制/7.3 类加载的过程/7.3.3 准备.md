---
title: 7.3.3 准备
tags: []
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
  - 第7章 虚拟机类加载机制
  - 7.3 类加载的过程
date: 2022-12-29 17:11:58
---

准备阶段是正式为**类中定义的变量**（也就是静态变量，被 static 修饰的变量）分配内存并设置类变量初始值的阶段。

从概念上讲，这些变量所使用的内存都应当在方法区中分配，但必须注意到方法区本身是一个逻辑上的区域，==在 JDK8 之后，类变量则会随着 Class 对象一起存放在 Java 堆中==，这时候”类变量在方法区“已经完全是一种对逻辑概念的表述了。具体可以参考（[[4 虚拟机性能监控、故障处理工具]]）。

关于准备阶段，还有两个需要注意的：

1. 在这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化的时候随着对象一起分配在 Java 堆中。
    也就是说，只有用 static 修饰的变量才会分配内存并且设置初始值，实例变量在对象实例化的时候才会进行内存的分配。
    更加具体来说。
   ```java
	public class A{
        public static int a = 123;
        public int b = 456;
    }
    ```
    对于这个类，被 `static` 修饰的变量 `a` 会在准备阶段被分配内存并且设置初始值 (`0`)，但是没有被 `static` 修饰的变量 `b` 则不会在准备阶段被分配内存，只会在 `new A()` 的时候才会分配内存。
1. 这里所说的初始值，**通常情况下**是数据类型的零值。
    还是上面的例子，变量 `a` 在准备阶段之后的初始值是 0 而不是 123，因为这时候尚未开始执行任何 Java 方法，而把 value 赋值为 123 的 `putstatic` 指令是程序被编译后，存放于类构造器 `<clinit>()` 之中，所以把 `value` 赋值为 123 的动作要到类的初始化阶段才会被执行。
	再次回忆我们这个图：
	<img src= https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20210810140918.png height=200>
	看到初始化在准备阶段之后，所以其不会那么快被赋值。

还需要注意的一点是，上面提到的是在“通常情况”下初始值是零值，也就是说会有一些“特殊情况”：如果类字段的字段属性表中存在 ConstantValue 属性，那在准备阶段变量值就会被初始化为 ConstantValue 属性所指定的初始值，假设上面的类变量 `a` 的定义修改为：

```java
public static final int value = 123;
```

编译时 Javac 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。