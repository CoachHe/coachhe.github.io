---
title: 7.3.1 加载
tags: []
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
  - 第7章 虚拟机类加载机制
  - 7.3 类加载的过程
date: 2022-12-29 17:11:16
---

注意：这里的加载≠类加载，只是类加载的一个阶段。

# 加载的理解

**所谓加载，简而言之就是将 Java 对象的字节码文件加载到机器内存中，并在内存中构建出 Java 类的原型**--称为==类模板对象==，作为方法区这个类的各种数据的访问入口。所谓类模板对象，其实就是 Java 类在 JVM 内存中的一个快照，JVM 将从字节码文件中解析出的常量池、类字段、类方法等信息存储到类模板中，这样 JVM 在运行期就能通过类模板而获取 Java 类中的任意信息，能够对 Java 类的成员变量进行遍历，也能进行 Java 方法的调用。反射的机制即基于这一基础。如果 JVM 没有将 Java 类的声明信息存储起来，则 JVM 在运行期也无法进行反射。

# 加载阶段完成的操作

**加载阶段，简言之，查找并加载类的而进行数据，生成 Class 的实例**。

在加载阶段，Java 虚拟机需要完成以下三件事情：
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的 `java.lang.Class` 对象。

# 二进制流的获取方式

注意：这个阶段是最灵活的一个阶段，也是开发人员可控性最强的阶段。

例如“通过一个类的全限定名来获取定义此类的二进制字节流”这条规则. 它并没有指明二进制字节流必须得从某个 Class 文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。仅仅这一点空隙，Java 虚拟机的使用者们就可以在加载阶段搭构建出一个相当开放广阔的舞台，Java 发展历程中，充满创造力的开发人员则在这个舞台上玩出了各种花样，许多举足轻重的 Java 技术都建立在这一基础之上，
- 例如最典型的从 ZIP 压缩包中读取，也就是日后 JAR 格式的基础。
- 从网络中获取
- 运行时计算生成，这种场景用的最多的就是动态代理技术。
- ...

# 类模型与 Class 实例的位置

## 类模型的位置

加载的类在 JVM 中创建相应的类结构，类结构会存储在方法区

## Class 实例的位置

类将 `.class` 文件加载至元空间后，会在堆中创建一个 `Java.lang.Class` 对象，用来封装类位于方法区内的数据结构，该 Class 对象是在加载类的过程中创建的，每个类都对应有一个 Class 类型对象。

## 图示

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20230110015340.png" width = "70%" />

外部可以通过访问代表 Order 类的 Class 对象来获取 Order 的类数据结构。

`java.lang.Class` 实例是访问类型元数据的接口，也是实现反射的关键数据、入库。通过 Class 类提供的接口，可以获得目标类所关联的 `.class` 文件中具体的数据结构：方法、字段等信息。


# 疑惑

1. C++中的对象分配在哪里？
2. 代码含义





加载阶段既可以使用 Java 虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的 `findClass()` 或 `loadClass()` 方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。

也就是说，加载阶段完成之后，类加载器已经调用过 loadClass 方法来生成一个 Class 对象了（具体可以看 [[Java反射浅析]])。

具体来说，加载阶段结束后，Java 虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java 虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在 Java 堆内存中实例化一个 java. lang. dass 类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。
