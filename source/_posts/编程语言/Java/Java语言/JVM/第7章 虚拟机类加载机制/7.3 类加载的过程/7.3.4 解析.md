---
title: 7.3.4 解析  
date: 2022-12-29 17:12:01  
tags: []  
---

解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。

回忆一下符号引用，在第 6 章（[[2 类文件结构]]）讲解 Class 文件格式的时候就已经出现了很多次，在 Class 文件中它以 CONSTANT_Class_info、CONSTANT_Methodref_info 等类型的常量出现。

### 直接引用和符号引用的关系

#### 符号引用
符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
符号引用与虚拟机的实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当众的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中。

#### 直接引用
直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，要引用的目标必定已经在虚拟机的内存中存在。


### 解析的时机
《Java 虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行 `anewarray`、`checkcast`、 `getfield`、`getstatic`、`instanceof`、`invokedynamic`、`invokeinterface`、`invokespecial`、`invokestatic`、`invokevirtual`、`Idc`、`ldc_w`、`ldc2_w`、`multianewarray`、`new`、`putfield` 和 `putstatic` 这 17 个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来**自行判断**，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

对同一个符号引用进行多次解析请求是很常见的事情，除 `invokedynamic` 指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。
**解释**：除了 invokedynamic 之外，其他情况下多次解析的结果是相同的，因此可以将常量标识为已解析状态并且记录在运行时常量池中，下次可以直接使用。

不过对于 `invokedynamic` 指令，上面的规则就不成立了。当碰到某个前面已经由 `invokedynamic` 指令触发过解析的符号引用时，并不意味着这个解析结果对于其他 `invokedynamic` 指令也同样生效。
因为 `invokedynamic` 指令的目的本来就是用于动态语言支持，它对应的引用称为“动态调用点限定符 (Dynamically-Computed Call Site Specifier)”

#### 动态的含义：
“动态”的含义是指必须等到程序实际运行到这条指令时，解析动作才能进行。相对地，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就提前进行解析。

### 解析的对象和对应常量类型
解析动作主要针对类和接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行，分别对应于常量池的的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、 CONSTANT_MethodHandle_info, CONSTANT_Dynamic_info 和 CONSTANT_InvokeDynamic_info 8 种常量类型。

### 解析过程

#### 1. 类和接口的解析
假设当前代码所处的类为 D，如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用，那虚拟机完成整个解析的过程需要包括以下 3 个步骤： 
1. 如果 C 不是一个数组类型，那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败
2. 如果 C 是一个数组类型，并且数组的元素类型为对象，也就是 N 的描述符会是类似 `[Ljava/lang/Integer` 的形式，那将会按照第一点的规则加载数组元素类型。如果 N 的描述符如前面所假设的形式，需要加载的元素类型就是“java. lang. Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象 C
3. 如果上面两步没有出现任何异常，那么 C 在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认 D 是否具备对 C 的访问权限。如果发现不具备访问权限，将抛出 java. lang. IllegalAccessError 异常，

总结一下，就是**先加载，然后检查访问权限**。

针对上面第 3 点访问权限验证，在 JDK9 引入了模块化以后，一个 public 类型也不再意味着程序任何位置都有它的访问权限，我们还必须检查模块间的访问权限。
如果我们说一个 D 拥有 C 的访问权限，那就意味着以下 3 条规则中至少有其中一条成立：
- 被访问类 C 是 public 的，并且与访问类 D 处于同一个模块。
- 被访问类 C 是 public 的，不与访问类 D 处于同一个模块，但是被访问类 C 的模块允许被访问类 D 的模块进行访问。
- 被访问类 C 不是 public 的，但是它与访问类 D 处于同一个包中。

#### 2. 字段解析
要解析一个未被解析过的字段符号引用，首先将会对字段表内 `class_index` 项中索引的 `CONSTANT_Class_info` 符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败如果解析成功完成，那把这个字段所属的类或接口用 `C` 表示，《Java 虚拟机规范》要求按照如下步骤对 `C` 进行后续字段的搜索：
1. 如果 `C` 本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返同这个字段的直接引用，查找结束。
2. 否则，如果在 `C` 中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
3. 否则，如果 `C` 不是 java. lang. Object 的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
4. 否则, 查找失败，抛出 java. lang. NoSuchFieldError 异常。

如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出 java. lang. IllegalAccessError 异常。

以上解析规则能够确保 Java 虚拟机获得字段唯一的解析结果，但在实际情况中，Javac 编译器往往会采取比上述规范更加严格一些的约束，譬如有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，按照解析规则仍是可以确定唯一的访问字段，但 Javac 编译器就可能直接拒绝其编译为 Class 文件。

```java
package com.coachhe.第4节_字段解析;

public class FieldResolution {
    interface Interface0{
        int A = 0;
    }
    interface Interface1 extends Interface0{
        int A = 1;
    }
    interface Interface2 {
        int A = 2;
    }
    static class Parent implements Interface1{
        public static int A = 3;
    }
    static class Sub extends Parent implements Interface2{
        public static int A = 4;
    }
    public static void main(String[] args) {
        System.out.println(Sub.A);
    }
}

```


#### 3. 方法解析
方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的 `class_index` 项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用 `C` 表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：
1. 由于 Class 文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现 class_index 中索引的 C 是个接口的话，那就直接抛出 java. lang. IncompatibleClassChangeError 异常。
2. 如果通过了第一步，在类 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在类 C 的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用，查找结束。
4. 否则，在类 C 实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类 C 是一个抽象类，这时候查找结束，抛出 java. lang. AbstractMethodError 异常。
5. 否则，宣告方法查找失败，抛出 java. lang. NoSuchMethodErrorc

最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出 java. lang. IllegalAccessError 异常。

#### 4. 接口方法解析
接口方法也是需要先解析出接口方法表的 `class_index` 项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用 C 表示这个接口，接下来虚拟机将会按照如下步骤

1. 与类的方法解析相反，如果在接口方法表中发现 class_index 中的索引 C 是个类而不是接口，那么就直接抛出 java. lang. IncompatibleClassChangeError 异常。
2. 否则，在接口 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在接口 C 的父接口中递归查找，直到 java. lang. Object 类（接口方法的查找范围也会包括 Object 类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4. 对于规则 3, 由于 Java 的接口允许多重继承，如果 C 的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，（Java 虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地，不同发行商实现的 Javac 编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。
5. 否则，宣告方法查找失败，抛出 java. lang. NoSuchMethodError 异常。



### 5. 初始化
类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由 Java 虚拟机来主导控制。直到初始化阶段，Java 虚拟机才真正开始执行类中编写的 Java 程序代码，将主导权移交给应用程序。

进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：
**初始化阶段就是执行类构造器 `<clinit＞()` 方法的过程。**

#### 注意：
`＜clinit＞()` 并不是程序员在 Java 代码中直接编写的方法，它是 Javac 编译器的自动生成物，但我们非常有必要了解这个方法具体是如何产生的，以及 `<clinit＞()` 方法执行过程中各种可能会影响程序运行行为的细节，这部分比起其他类加载过程更贴近于普通的程序开发人员的实际工作。

#### 1. Clinit 方法的产生
`<clinit>()` 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的
顺序：
编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，（这是因为在前面的准备阶段中已经赋予了一个初值，因此可以进一步进行赋值，但是不能访问，因为实际上还没有被创建出来) 但是不能访问。

##### 示例
```java
public class IllegalForwardReference {  
    /**  
     * 非法向前引用变量  
     * 在这里第一次打印i失败了，第二次打印i就成功了，这是因为在初始化过程中执行clinit方法，这个方法是顺序执行的，  
     * 第一次打印i时，还没有对i进行定义，因此打印失败了。  
     * 第二次打印i时，已经成功定义了，所以打印成功了  
     */  
    static {  
        i = 0; //给变量赋值是可以正常编译通过的  
//        System.out.println(i); //这句编译器会提示"非法向前引用",illegal forward reference  
    }  
    static int i = 1;  
    static {  
        System.out.println(i); // 在这里就可以正常使用i这个值了  
    }
}
```

#### 2. 父类构造器的执行
Java 虚拟机会保证在子类的 `<clinit>()` 方法执行前，父类的 `<clinit>()` 方法已经执行完毕。因此在 Java 虚拟机中第一个被执行的 `<clinit>()` 方法一定是 `java.lang.object`
父类的 `<clinit>()` 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
##### 示例
```java
/**  
 * clint方法执行顺序示例  
 */  
static class Parent {  
    public static int A = 1;  
    static {  
        A = 2;  
    }  
}  
static class Sub extends Parent {  
    public static int B = A;  
}  
public static void main(String[] args) {  
    // 在这里打印的是2，因为父类中的静态语句要优于子类的变量赋值操作  
 System.out.println(Sub.B);  
}
```

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20211213125423.png" width="50%">

#### 3.  `<clinit>()` 方法的必须性
 `<clinit>()` 方法不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 `<clinit>()` 方法
 
#### 4.  `<clinit>()` 方法初始化加锁
Java 虚拟机必须要保证一个类的 `<clinit>()` 方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的 `<clinit>()` 方法，其他线程都需要阻塞等待，知道活动线程执行完毕 `<clinit>()` 方法。如果一个类的 `<clinit>()` 方法中有耗时很长的操作，那就可能造成多个进程阻塞。

##### 示例
```java

package com.coachhe.第5节_初始化;  
  
/**  
 * 当多个线程同时去初始化一个类时，只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待  
 * 直到活动线程执行完毕<clinit>()方法。  
 * 因此，如果在一个类<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞  
 * 接下来进行展示：  
 */  
public class DeadLoopClass {  
    static class DealLoopClassTest {  
        static {  
            if (true) {  
                System.out.println(Thread.currentThread() + "init DeadLoopClass");  
                while (true) {  
                }  
            }  
        }  
    }  
  
    public static void main(String[] args) {  
        Runnable script = () -> {  
            System.out.println("Thread.currentThread() " + "start");  
            DealLoopClassTest dlc = new DealLoopClassTest ();  
            System. out. println ("Thread. currentThread () " + "run over");  
        };  
  
        Thread thread1 = new Thread(script);  
        Thread thread2 = new Thread(script);  
        thread1.start();  
        thread2.start();  
    }  
}
```

运行结果为：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20211213130235.png" width="50%">

