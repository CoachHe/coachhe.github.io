---
title: 7.3.4 解析
tags: []
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
  - 第7章 虚拟机类加载机制
  - 7.3 类加载的过程
date: 2022-12-29 17:12:01
---

解析阶段是 Java 虚拟机将常量池内的符号引用替换为直接引用的过程。

回忆一下符号引用，在第 6 章（[[2 类文件结构]]）讲解 Class 文件格式的时候就已经出现了很多次，在 Class 文件中它以 CONSTANT_Class_info、CONSTANT_Methodref_info 等类型的常量出现。

# 直接引用和符号引用的关系

## 符号引用

符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
符号引用与虚拟机的实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当众的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在《Java 虚拟机规范》的 Class 文件格式中。

## 直接引用

直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，要引用的目标必定已经在虚拟机的内存中存在。


# 解析的时机

《Java 虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行 `anewarray`、`checkcast`、 `getfield`、`getstatic`、`instanceof`、`invokedynamic`、`invokeinterface`、`invokespecial`、`invokestatic`、`invokevirtual`、`Idc`、`ldc_w`、`ldc2_w`、`multianewarray`、`new`、`putfield` 和 `putstatic` 这 17 个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来**自行判断**，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

对同一个符号引用进行多次解析请求是很常见的事情，除 `invokedynamic` 指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。
**解释**：除了 invokedynamic 之外，其他情况下多次解析的结果是相同的，因此可以将常量标识为已解析状态并且记录在运行时常量池中，下次可以直接使用。

不过对于 `invokedynamic` 指令，上面的规则就不成立了。当碰到某个前面已经由 `invokedynamic` 指令触发过解析的符号引用时，并不意味着这个解析结果对于其他 `invokedynamic` 指令也同样生效。
因为 `invokedynamic` 指令的目的本来就是用于动态语言支持，它对应的引用称为“动态调用点限定符 (Dynamically-Computed Call Site Specifier)”

## 动态的含义：

“动态”的含义是指必须等到程序实际运行到这条指令时，解析动作才能进行。相对地，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就提前进行解析。

# 解析的对象和对应常量类型

解析动作主要针对类和接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这 7 类符号引用进行，分别对应于常量池的的 CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、 CONSTANT_MethodHandle_info, CONSTANT_Dynamic_info 和 CONSTANT_InvokeDynamic_info 8 种常量类型。

# 解析过程

## 1. 类和接口的解析

假设当前代码所处的类为 D，如果要把一个从未解析过的符号引用 N 解析为一个类或接口 C 的直接引用，那虚拟机完成整个解析的过程需要包括以下 3 个步骤： 
1. 如果 C 不是一个数组类型，那虚拟机将会把代表 N 的全限定名传递给 D 的类加载器去加载这个类 C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败
2. 如果 C 是一个数组类型，并且数组的元素类型为对象，也就是 N 的描述符会是类似 `[Ljava/lang/Integer` 的形式，那将会按照第一点的规则加载数组元素类型。如果 N 的描述符如前面所假设的形式，需要加载的元素类型就是“java. lang. Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象 C
3. 如果上面两步没有出现任何异常，那么 C 在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认 D 是否具备对 C 的访问权限。如果发现不具备访问权限，将抛出 java. lang. IllegalAccessError 异常，

总结一下，就是**先加载，然后检查访问权限**。

针对上面第 3 点访问权限验证，在 JDK9 引入了模块化以后，一个 public 类型也不再意味着程序任何位置都有它的访问权限，我们还必须检查模块间的访问权限。
如果我们说一个 D 拥有 C 的访问权限，那就意味着以下 3 条规则中至少有其中一条成立：
- 被访问类 C 是 public 的，并且与访问类 D 处于同一个模块。
- 被访问类 C 是 public 的，不与访问类 D 处于同一个模块，但是被访问类 C 的模块允许被访问类 D 的模块进行访问。
- 被访问类 C 不是 public 的，但是它与访问类 D 处于同一个包中。

## 2. 字段解析

要解析一个未被解析过的字段符号引用，首先将会对字段表内 `class_index` 项中索引的 `CONSTANT_Class_info` 符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败如果解析成功完成，那把这个字段所属的类或接口用 `C` 表示，《Java 虚拟机规范》要求按照如下步骤对 `C` 进行后续字段的搜索：
1. 如果 `C` 本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返同这个字段的直接引用，查找结束。
2. 否则，如果在 `C` 中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
3. 否则，如果 `C` 不是 java. lang. Object 的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
4. 否则, 查找失败，抛出 java. lang. NoSuchFieldError 异常。

如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出 java. lang. IllegalAccessError 异常。

以上解析规则能够确保 Java 虚拟机获得字段唯一的解析结果，但在实际情况中，Javac 编译器往往会采取比上述规范更加严格一些的约束，譬如有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，按照解析规则仍是可以确定唯一的访问字段，但 Javac 编译器就可能直接拒绝其编译为 Class 文件。

```java
package com.coachhe.第4节_字段解析;

public class FieldResolution {
    interface Interface0{
        int A = 0;
    }
    interface Interface1 extends Interface0{
        int A = 1;
    }
    interface Interface2 {
        int A = 2;
    }
    static class Parent implements Interface1{
        public static int A = 3;
    }
    static class Sub extends Parent implements Interface2{
        public static int A = 4;
    }
    public static void main(String[] args) {
        System.out.println(Sub.A);
    }
}

```


## 3. 方法解析

方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的 `class_index` 项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用 `C` 表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：
1. 由于 Class 文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现 class_index 中索引的 C 是个接口的话，那就直接抛出 java. lang. IncompatibleClassChangeError 异常。
2. 如果通过了第一步，在类 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在类 C 的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用，查找结束。
4. 否则，在类 C 实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类 C 是一个抽象类，这时候查找结束，抛出 java. lang. AbstractMethodError 异常。
5. 否则，宣告方法查找失败，抛出 java. lang. NoSuchMethodErrorc

最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出 java. lang. IllegalAccessError 异常。

## 4. 接口方法解析

接口方法也是需要先解析出接口方法表的 `class_index` 项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用 C 表示这个接口，接下来虚拟机将会按照如下步骤

1. 与类的方法解析相反，如果在接口方法表中发现 class_index 中的索引 C 是个类而不是接口，那么就直接抛出 java. lang. IncompatibleClassChangeError 异常。
2. 否则，在接口 C 中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在接口 C 的父接口中递归查找，直到 java. lang. Object 类（接口方法的查找范围也会包括 Object 类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4. 对于规则 3, 由于 Java 的接口允许多重继承，如果 C 的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，（Java 虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地，不同发行商实现的 Javac 编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。
5. 否则，宣告方法查找失败，抛出 java. lang. NoSuchMethodError 异常。



