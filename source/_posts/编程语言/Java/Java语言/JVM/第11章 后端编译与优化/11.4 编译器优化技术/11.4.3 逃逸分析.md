---
title: 11.4.3 逃逸分析  
date: 2023-01-02 02:11:25  
tags: []  
---

逃逸分析（Escape Analysis）是目前 Java 虚拟机中比较前沿的优化技术，它与类型继承关系分析一样，并不是直接优化代码的手段，而是为其他优化措施提供依据的分析技术。

随着 JIT 编译器的发展与**逃逸分析技术**逐渐成熟，**栈上分配、标量替换优化技术**将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对“了。


# 逃逸分析的原理

## 方法逃逸

分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，这种称为方法逃逸；

## 线程逃逸

分析对象动态作用域，当一个对象在方法里面被定义后，它可能被外部线程访问到，譬如赋值给可以在其他线程中访问的实例变量，这种称为线程逃逸；

## 逃逸分析举例

```java
/**
 * @author CoachHe
 * @date 2023/1/2 02:37
 * 逃逸分析
 *  如何快速的判断是否发生逃逸分析，大家就看new的对象实体是否有可能在方法外被调用
 **/
public class EscapeAnalysis {
    public EscapeAnalysis obj;

    /**
     * 方法返回EscapeAnalysis对象，发生逃逸
     */
    public EscapeAnalysis getInstance() {
        return obj == null ? new EscapeAnalysis() : obj;
    }

    /**
     * 为成员属性赋值
     */
    public void setObj() {
        this.obj = new EscapeAnalysis();
    }

    // 思考：如果当前的obj引用声明为static的，是否会发生逃逸？回答：仍然是会发生逃逸的

    /**
     * 对象的作用域仅在当前方法中有效，没有发生逃逸
     */
    public void useEscapeAnalysis() {
        EscapeAnalysis es = new EscapeAnalysis();
    }

    /**
     * 引用成员变量的值，发生逃逸
     */
    public void useEscapeAnalysis1() {
        EscapeAnalysis e = getInstance();
    }
}
```

## 逃逸程度

从不逃逸、方法逃逸到线程逃逸，称为对象由低到高的不同逃逸程度。



# 逃逸分析进行的优化

如果能证明一个对象不会逃逸到方法或线程之外（也就是说别的方法或线程无法通过任何途径访问到这个对象），或者逃逸程度比较低（只能逃逸出方法而不会逃逸出线程），则可能为这个对象实例采取不同程度的优化。

典型的如：

```java
public void my_method() {
	V v = new V();
	// use v
	// ...
	v = null;
}
```

可以看到，这里的 v 就没有逃逸出方法，有可能就可以进行优化；

如：

- 栈上分配（Stack Allocations）
- 标量替换（Scalar Replacement）
- 同步消除（Synchronization Elimination）

## 栈上分配

在 Java 虚拟机中，Java 堆上分配创建对象的内存空间几乎是 Java 程序员都知道的常识，Java 堆中的对象对于各个线程都是共享和可见的，只要持有这个对象的引用，就可以访问到堆中存储的对象数据。虚拟机的垃圾收集子系统会回收堆中不再使用的对象，但回收动作无论是标记筛选出可回收对象，还是回收和整理内存，都需要耗费大量资源。

**如果确定一个对象不会逃逸出线程之外，那让这个对象在栈上分配内存将会是一个很不错的主意，对象所占用的内存空间就可以随栈帧出栈而销毁**。

在一般应用中，完全不会逃逸的局部对象和不会逃逸出线程的对象所占的比例是很大的，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集子系统的压力将会下降很多。

### 对方法逃逸和线程逃逸的支持

栈上分配可以支持方法逃逸，但不能支持线程逃逸。

### 举例

```java
/**
 * @author CoachHe
 * @date 2023/1/2 02:49
 * 栈上分配
 * VM参数
 *  -Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails
 **/
public class StackAllocations {
    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        for (int i = 0; i < 10000000; i++) {
            alloc();
        }
        // 查看执行时间
        long end = System.currentTimeMillis();
        System.out.println("花费的时间为： " + (end - start) + " ms");
        // 为了方便查看堆内存中对象的个数，现成sleep
        try {
            Thread.sleep(1000000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    private static void alloc() {
        User user = new User(); //未发生逃逸
    }
    static class User {}
}
```

可以看到，这里我们的 VM 的参数是：

```java
-Xmx1G -Xms1G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails
```

此时是没有打开逃逸分析的，因此这 10000000 个对象全部都会创建在堆空间中，我们可以看下运行结果：

```txt
花费的时间为： 126 ms
```

然后打开 VisualVM：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20230102025740.png" width = "80%" />

可以看到，`User` 对象实打实创建了 10000000 个。

此时我们打开逃逸分析，将 VM 参数修改为：

```java
-Xmx1G -Xms1G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails
```

首先我们来看下运行结果：

```txt
花费的时间为： 4 ms
```

时间大量减少了，然后再看下 VisualVM：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20230102030051.png" width = "80%" />

可以看到，User 的对象数量一共 10 万个，已经比 1000 万少很多了。时间也快了很多。

然后我们再看下，将 VM 参数修改为：

```java
-Xmx256m -Xms256m -XX:-DoEscapeAnalysis -XX:+PrintGCDetails
```

将堆空间调整为 256M，也就是理论上会发生 GC，我们先关闭逃逸分析来看下效果：





