---
title: 3 字节码指令简介
tags: []
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
  - 第6章 类文件结构
date: 2022-12-19 11:29:38
---

Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字 （称为操作码， Opcode）以及跟随其后的零至多个代表此操作所需的参数（称为操作数，Operand）构成。 由于Java虚拟机采用面向操作数栈而不是面向寄存器的架构（这两种架构的执行过程、区别和影响将在第8章中探讨），所以大多数指令都不包含操作数，只有一个操作码，指令参数都存放在操作数栈中。

## 字节码指令伪代码
如果不考虑异常处理的话，那Java虚拟机的解释器可以使用下面这段伪代码作为最基本的执行模型来理解，这个执行模型虽然很简单，但依然可以有效正确地工作：
```cpp
do {
    自动计算PC寄存器的值加1;
	根据PC寄存器指示的位置，从字节码流中取出操作码；
	if(字节码存在操作数):
		从字节码流中取出操作数；
	执行操作码所定义的操作；
} while(字节码流长度＞0);
```

## 字节码与数据类型

在Java虚拟机的指令集中，大多数指令都包含其操作所对应的数据类型信息。

例如 iload 指令用于从局部变量中加载 int 型的数据到操作数栈中，而 fload 指令加载的则是 float 类型的数据。

因为 Java 虚拟机的操作码长度只有一字节，所以包含了数据类型的操作码就为指令集的设计带来了很大压力：如果每一种与数据类型相关的指令都支持 Java 虚拟机所有运行时数据类型的话，那么指令的数量恐怕就会超出一字节所能表示的数量范围了。

**理解**：

每个数据类型都有对应的操作，例如 byte 类型，应该有 push, const, load, store, increase,.... 非常多指令，同样，short、int、long 都应该有对应的那么多指令，如果每个指令都有对应的操作码，那么操作码长度早就超过 1 字节了。

因此，Java虚拟机的指令集对于特定的操作只提供了优先的类型相关指令去支持它，换句话说，Java虚拟机会被故意设计成非完全独立的，也就是很多指令可以共用同一条指令。

### 设计方法

大部分指令都没有支持整数类型byte、char和short,甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean,byte, short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean, byte, short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。

### 加载和存储指令

加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈（见[[2.3.2 虚拟机栈]]）之间来回传输，这类指令包括：
- 将一个局部变量加载到操作栈：iload、iload\_\<n\>、lload\_\<n\>、fload、fload\_\<n\>、dload、dload\_\<n\>、aload、aload\_\<n\>
- 将一个数值从操作数栈存储到局部变量表：istore、istore\_\<n\>、Istore、lstore_\<n\>、fstore、fstore\_\<n\>、dstore、dstore\_\<n\>、astore、astore\_\<n\> 
- 将一个常量加载到操作数栈：bipush、sipush、Idc、ldc_w、ldc2_w、aconst_null、iconst\_m1、iconst\__\<i\>、Iconst\_\<1\>、fconst\_\<f\>、dconst\_\<d\>
- 扩充局部变量表的访问索引的指令：wide

存储数据的操作数栈和局部变量表主要由加载和存储指令进行操作，除此之外，还有少量指令，如访问对象的字段或数组元素的指令也会向操作数栈传输数据。

### 运算指令

算术指令用于对操作数栈上的两个值进行某种特定运算，并把结果重新存入到操作栈顶。

#### 运算指令分类

大体上运算指令可以分为两种：
1. 对整型数据进行运算的指令
2. 对浮点型数据进行运算的指令。

整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现。无论是哪种算术指令，均是使用Java虚拟机的算术类型来进行计算的，换句话说是不存在直接支持byte、short、char和boolean类型的算术指令，对于上述几种数据的运算，应使用操作 int类型的指令代替。

### 类型转换指令

类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户 代码中的显式类型转换操作，或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。

Java虚拟机直接支持(即转换时无须显式的转换指令)以下数值类型的宽化类型转换 (Widening Numeric Conversion,即小范围类型向大范围类型的安全转换)：
- int类型到long、float或者double类型
- long 类型到 float、double 类型
- float类型到double类型

与之相对的，处理窄化类型转换 (Narrowing Numeric Conversion) 时，就必须显式地使用转换指令来完成，这些转换指令包括 i2b、i2c、i2s、12i、f2i、⑵、d2i、d21 和 d2f。

窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况，转换过程很可能会导致数值的精度丢失。

### 对象的创建于访问指令

虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素，
