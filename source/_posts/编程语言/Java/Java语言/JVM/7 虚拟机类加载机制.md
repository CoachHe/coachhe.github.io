---
title: 7 虚拟机类加载机制  
date: 2022-12-04 02:20:59  
tags: []  
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
---

# 概述

《深入理解JVM》原话：

虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被直接使用的Java类型，这就是虚拟机的类加载机制。

**注意**：
这里指的Class文件不一定是本地的.class文件，而应该是一串二进制的字节流，无论什么形式都可以。

## Java语言类型加载、连接和初始化特点

在 Java 语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的。

- 缺点：让Java语言进行提前编译会面临额外的困难，也会让类加载时稍微增加一些性能开销
- 优点：为Java应用提供了极高的拓展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。

理解：
也就是说，在编写一个面向接口的应用程序的时候，可以等到运行时再指定其实际的实现类，用户可以通过Java预置的或自定义类加载器，让某个本地的应用程序在运行时从网络或者其他地方加载一个二进制流作为其程序代码的一部分。
例如，我们有一个接口：

```java
public interface Phone(){
    void call();
}
```

然后我们有对应的main方法：
```java
public class Test {
    public static void main(String[] args) throws Exception {
        Class phoneClass = Class.forName("xxx");
        Phone phone = (Phone) phoneClass.newInstance();
        phone.call();
    }
}
```

可以看到，我们可以在运行时动态加载，通过一些自定义的类加载器可以在运行时再确认具体的类型。

## 类加载器子系统作用
<img src="https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20211209133115.png" width = "50%">
1. 类加载器子系统负责从文件系统或者网络中加载 Class 文件
2. ClassLoader 只负责 class 文件的加载，至于是否它可以运行，则有 Execution Engine 决定
3. 加载的类信息存放于一块成为**方法区**的内存空间。除了类的信息外，方法区中还会存放运行时常量池信息，可能还包括字符串字面量和数字常量（这部分常量信息是 Class 文件中常量池部分的内存映射）

## 类加载器 ClassLoader 角色








# 类加载的时机
这部分建议结合[[2 Java内存区域与内存溢出异常]]中的**对象探秘**章节来进行学习，能加深对这部分知识的理解。

## 类的生命周期
类的生命周期共分为7个阶段。

<img src=https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20210810140918.png height=260>

图中黑色字体部分的顺序是确定的。其余字体（解析和使用）的顺序不一定，解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的**动态绑定**。

对于加载开始的时机，虚拟机规范并没有给强制的要求，但是对于初始化阶段, 《Java虚拟机规范》则是严格规定了**有且只有**六种情况必须立即对类进行“初始化”(而加载、 验证、准备自然需要在此之前开始)：
1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令
能生成这四条指令的典型Java代码场景有：
	1 使用new关键字实例化对象
	2 读取或设置一个类型的静态字段（被final修饰、已在编译器把结果放入常量池的静态字段除外）的时候
	3 调用一个类型的静态方法的时候
2. 使用java.lang.reflect包的方法对类型进行反射调用的时候
3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main。方法的那个类） 虚拟机会先初始化这个主类。
5. 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为 REF_getStatic、REF_putStatic、REF invokeStatic、REF newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。
6. 当一个接口中定义了 JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。

注意：
**有且仅有**这六种情况的行为会触发类型进行初始化。也就是说，其他的任何情况都不会触发初始化。

### 主动引用和被动引用
上面介绍的这六种初始化场景中的行为称为对一个类进行**主动引用**。除此之外，所有引用类型的方法都不会触发初始化，称为**被动引用**。
这里给出三个被动引用的例子。
举例1：
通过子类引用父类的静态方法，不会导致子类初始化。

```java
// 父类
public class SuperClass {
    static {
        System.out.println("SuperClass init");
    }
	public static int value = 123;
}

// 子类
public class SubClass extends SuperClass{
    static {
        System.out.println("SubClass init");
    }
}

// Main方法
public class NotInitialization {
    public static void main(String[] args) {
        System.out.println(SubClass.value);
    }
}
```
结果：
<img src=https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20210815162433.png height=200>

分析：
在这里，我们看到只输出了SuperClass init，而没有输出SubClass init，这是因为对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过其子类来引用父类中定义的静态字段，只会触发父类的初始化而不会触发子类的初始化。

举例2：
通过数组定义来引用类，不会触发此类的初始化

```java
public class NotInitialization2 {
    public static void main(String[] args) {
        SuperClass[] sca = new SuperClass[10];
    }
}
```
结果：
<img src=https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20210815162910.png height=200>
分析：
可以看到，这里没有输出，说明并没有出发类SuperClass的初始化阶段。

举例3：
常量在编译阶段会存储调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类初始化：

```java
// ConstClass类

public class ConstClass {
    static {
        System.out.println("ConstClass init");
    }
}

// Main方法
public class NotInitialization3 {
    public static void main(String[] args) {
        System.out.println(ConstClass.HELLOWORLD);
    }
}

```
结果：
<img src=https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20210815163256.png height=200>

分析：
只输出了"hello world"没有输出ConstClass init，这是因为虽然在Java源码中确实引用了ConstClass类的常量HELLOWORLD，但其实在编译阶段通过常量传播优化，已经将常量值（也就是被final修饰的值）”hello world"直接存储在NotInitialization3类的常量池中，所以以后NotInitialization3对ConstClass.HELLOWORLD的引用，实际都转化成对自己常量池的引用了。
也就是说，实际上Notlnitialization的Class文件之中并没有ConstClass类的符号引用入口,这两个类在编译成Class文件后就已不存在任何联系了。
用代码来表示就是：
对于用final修饰的常量，直接使用和引用是一样的效果。
在我们这里，`System.out.println(ConstClass.HELLOWORLD)`等价于`System.out.println("ConstClass init")`。


# 类加载的过程
## 1. 加载
注意：这里的加载≠类加载，只是类加载的一个阶段。
在加载阶段，Java虚拟机需要完成以下三件事情：
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

注意：
这个阶段是最灵活的一个阶段，也是开发人员可控性最强的阶段。
例如“通过一个类的全限定名来获取定义此类的二进制字节流”这条规则.它并没有指明二进制字节流必须得从某个Class文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。仅仅这一点空隙，Java虚拟机的使用者们就可以在加载阶段搭构建出一个相当开放广阔的舞台，Java发展历程中，充满创造力的开发人员则在这个舞台上玩出了各种花样，许多举足轻重的Java技术都建立在这一基础之上，
- 例如最典型的从ZIP压缩包中读取，也就是日后JAR格式的基础。
- 从网络中获取
- 运行时计算生成，这种场景用的最多的就是动态代理技术。
- ...

加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员 通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。

也就是说，加载阶段完成之后，类加载器已经调用过loadClass方法来生成一个Class对象了（具体可以看[[Java反射浅析]])。

具体来说，加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.dass类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。

## 2. 验证
首先我们介绍一下连接阶段，这个阶段公共分为三个部分：
- 验证
- 准备
- 解析

解析阶段的目的是确保Class文件的字节流包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当成代码运行后不会危害虚拟机自身的安全。

验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击，从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。

### 验证的几个阶段
1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证


## 3. 准备
准备阶段是正式为**类中定义的变量**（也就是静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。

从概念上讲，这些变量所使用的内存都应当在方法区中分配，但必须注意到方法区本身是一个逻辑上的区域，==在JDK8之后，类变量则会随着Class对象一起存放在Java堆中==，这时候”类变量在方法区“已经完全是一种对逻辑概念的表述了。具体可以参考（[[4 虚拟机性能监控、故障处理工具]]）。

关于准备阶段，还有两个需要注意的：

1. 在这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中。
    也就是说，只有用static修饰的变量才会分配内存并且设置初始值，实例变量在对象实例化的时候才会进行内存的分配。
    更加具体来说。
   ```java
	public class A{
        public static int a = 123;
        public int b = 456;
    }
    ```
    对于这个类，被`static`修饰的变量`a`会在准备阶段被分配内存并且设置初始值(`0`)，但是没有被`static`修饰的变量`b`则不会在准备阶段被分配内存，只会在`new A()`的时候才会分配内存。
1. 这里所说的初始值，**通常情况下**是数据类型的零值。
    还是上面的例子，变量`a`在准备阶段之后的初始值是0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的`putstatic`指令是程序被编译后，存放于类构造器`<clinit>()`之中，所以把`value`赋值为123的动作要到类的初始化阶段才会被执行。
	再次回忆我们这个图：
	<img src=https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20210810140918.png height=200>
	看到初始化在准备阶段之后，所以其不会那么快被赋值。

还需要注意的一点是，上面提到的是在“通常情况”下初始值是零值，也就是说会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，假设上面的类变量`a`的定义修改为：

```java
public static final int value = 123;
```

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

## 4. 解析
解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。

回忆一下符号引用，在第6章（[[6 类文件结构]]）讲解Class文件格式的时候就已经出现了很多次，在Class文件中它以CONSTANT_Class_info、CONSTANT_Methodref_info等类型的常量出现。

### 直接引用和符号引用的关系

#### 符号引用
符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
符号引用与虚拟机的实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当众的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。

#### 直接引用
直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，要引用的目标必定已经在虚拟机的内存中存在。


### 解析的时机
《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行`anewarray`、`checkcast`、 `getfield`、`getstatic`、`instanceof`、`invokedynamic`、`invokeinterface`、`invokespecial`、`invokestatic`、`invokevirtual`、`Idc`、`ldc_w`、`ldc2_w`、`multianewarray`、`new`、`putfield` 和 `putstatic`这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来**自行判断**，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

对同一个符号引用进行多次解析请求是很常见的事情，除`invokedynamic`指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。
**解释**：除了invokedynamic之外，其他情况下多次解析的结果是相同的，因此可以将常量标识为已解析状态并且记录在运行时常量池中，下次可以直接使用。

不过对于`invokedynamic`指令，上面的规则就不成立了。当碰到某个前面已经由`invokedynamic`指令触发过解析的符号引用时，并不意味着这个解析结果对于其他`invokedynamic`指令也同样生效。
因为`invokedynamic`指令的目的本来就是用于动态语言支持，它对应的引用称为“动态调用点限定符(Dynamically-Computed Call Site Specifier)”

#### 动态的含义：
“动态”的含义是指必须等到程序实际运行到这条指令时，解析动作才能进行。相对地，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就提前进行解析。

### 解析的对象和对应常量类型
解析动作主要针对类和接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行，分别对应于常量池的的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、 CONSTANT_MethodHandle_info, CONSTANT_Dynamic_info和CONSTANT_InvokeDynamic_info 8种常量类型。

### 解析过程
#### 1. 类和接口的解析
假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤： 
1. 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败
2. 如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似`[Ljava/lang/Integer`的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象C
3. 如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常，

总结一下，就是**先加载，然后检查访问权限**。

针对上面第3点访问权限验证，在JDK9引入了模块化以后，一个public类型也不再 意味着程序任何位置都有它的访问权限，我们还必须检查模块间的访问权限。
如果我们说一个D拥有C的访问权限，那就意味着以下3条规则中至少有其中一条成立：
- 被访问类C是public的，并且与访问类D处于同一个模块。
- 被访问类C是public的，不与访问类D处于同一个模块，但是被访问类C的模块 允许被访问类D的模块进行访问。
- 被访问类C不是public的，但是它与访问类D处于同一个包中。

#### 2. 字段解析
要解析一个未被解析过的字段符号引用，首先将会对字段表内`class_index`项中索引的`CONSTANT_Class_info`符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败如果解析成功完成，那把这个字段所属的类或接口用`C`表示，《Java虚拟机规范》要求按照如下步骤对`C`进行后续字段的搜索：
1. 如果`C`本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返同这个字段的直接引用，查找结束。
2. 否则，如果在`C`中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
3. 否则，如果`C`不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
4. 否则,查找失败，抛出 java.lang.NoSuchFieldError 异常。

如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。

以上解析规则能够确保Java虚拟机获得字段唯一的解析结果，但在实际情况中，Javac编译器往往会采取比上述规范更加严格一些的约束，譬如有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，按照解析规则仍是可以确定唯一的访问字段，但Javac编译器就可能直接拒绝其编译为Class文件。

```java
package com.coachhe.第4节_字段解析;

public class FieldResolution {
    interface Interface0{
        int A = 0;
    }

    interface Interface1 extends Interface0{
        int A = 1;
    }

    interface Interface2 {
        int A = 2;
    }

    static class Parent implements Interface1{
        public static int A = 3;
    }

    static class Sub extends Parent implements Interface2{
        public static int A = 4;
    }

    public static void main(String[] args) {
        System.out.println(Sub.A);
    }
}

```


#### 3. 方法解析
方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的`class_index`项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用`C`表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：
1. 由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的 ， 如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang. IncompatibleClassChangeError 异常。
2. 如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方 法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用，查找结束。
4. 否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述 符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结 束，抛出 java.lang.AbstractMethodError 异常。
5. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodErrorc

最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。

#### 4. 接口方法解析
接口方法也是需要先解析出接口方法表的`class_index`项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤

1. 与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出 java.lang.IncompatibleClassChangeError 异常。
2. 否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4. 对于规则3,由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，（Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。
5. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。



### 5. 初始化
类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由 Java 虚拟机来主导控制。直到初始化阶段，Java 虚拟机才真正开始执行类中编写的 Java 程序代码，将主导权移交给应用程序。

进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：
**初始化阶段就是执行类构造器 `<clinit＞()` 方法的过程。**

#### 注意：
`＜clinit＞()` 并不是程序员在 Java 代码中直接编写的方法，它是 Javac 编译器的自动生成物，但我们非常有必要了解这个方法具体是如何产生的，以及 `<clinit＞()` 方法执行过程中各种可能会影响程序运行行为的细节，这部分比起其他类加载过程更贴近于普通的程序开发人员的实际工作。

#### 1. Clinit 方法的产生
`<clinit>()` 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的
顺序：
编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，（这是因为在前面的准备阶段中已经赋予了一个初值，因此可以进一步进行赋值，但是不能访问，因为实际上还没有被创建出来) 但是不能访问。

##### 示例
```java
public class IllegalForwardReference {  
    /**  
     * 非法向前引用变量  
     * 在这里第一次打印i失败了，第二次打印i就成功了，这是因为在初始化过程中执行clinit方法，这个方法是顺序执行的，  
     * 第一次打印i时，还没有对i进行定义，因此打印失败了。  
     * 第二次打印i时，已经成功定义了，所以打印成功了  
     */  
    static {  
        i = 0; //给变量赋值是可以正常编译通过的  
//        System.out.println(i); //这句编译器会提示"非法向前引用",illegal forward reference  
    }  
    static int i = 1;  
    static {  
        System.out.println(i); // 在这里就可以正常使用i这个值了  
    }
}
```

#### 2. 父类构造器的执行
Java 虚拟机会保证在子类的 `<clinit>()` 方法执行前，父类的 `<clinit>()` 方法已经执行完毕。因此在 Java 虚拟机中第一个被执行的 `<clinit>()` 方法一定是 `java.lang.object`
父类的 `<clinit>()` 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
##### 示例
```java
/**  
 * clint方法执行顺序示例  
 */  
static class Parent {  
    public static int A = 1;  
    static {  
        A = 2;  
    }  
}  
static class Sub extends Parent {  
    public static int B = A;  
}  
public static void main(String[] args) {  
    // 在这里打印的是2，因为父类中的静态语句要优于子类的变量赋值操作  
 System.out.println(Sub.B);  
}
```

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20211213125423.png" width="50%">

#### 3.  `<clinit>()` 方法的必须性
 `<clinit>()` 方法不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 `<clinit>()` 方法
 
#### 4.  `<clinit>()` 方法初始化加锁
Java 虚拟机必须要保证一个类的 `<clinit>()` 方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的 `<clinit>()` 方法，其他线程都需要阻塞等待，知道活动线程执行完毕 `<clinit>()` 方法。如果一个类的 `<clinit>()` 方法中有耗时很长的操作，那就可能造成多个进程阻塞。

##### 示例
```java

package com.coachhe.第5节_初始化;  
  
/**  
 * 当多个线程同时去初始化一个类时，只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待  
 * 直到活动线程执行完毕<clinit>()方法。  
 * 因此，如果在一个类<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞  
 * 接下来进行展示：  
 */  
public class DeadLoopClass {  
    static class DealLoopClassTest {  
        static {  
            if (true) {  
                System.out.println(Thread.currentThread() + "init DeadLoopClass");  
                while (true) {  
                }  
            }  
        }  
    }  
  
    public static void main(String[] args) {  
        Runnable script = () -> {  
            System.out.println("Thread.currentThread() " + "start");  
            DealLoopClassTest dlc = new DealLoopClassTest();  
            System.out.println("Thread.currentThread() " + "run over");  
        };  
  
        Thread thread1 = new Thread(script);  
        Thread thread2 = new Thread(script);  
        thread1.start();  
        thread2.start();  
    }  
}
```

运行结果为：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20211213130235.png" width="50%">


# 类加载器

<img src="https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20211213132247.png" width="50%">

可以看到，用户自定义类的默认类加载器就为系统类加载器，bootstrap 类加载器（引导类加载器）为 null（不是用 Java 语言实现，不是一个类），String 的类加载器也为 bootstrap 类加载器

## 类加载器的分类
### 启动类加载器（bootstrap 类加载器）
1. 也叫引导类加载器，使用 C/C++ 语言实现，嵌套在 JVM 内部。
2. 用来将 Java 的核心库（ `<JAVA_HOME>\lib` 目录，或者被 `-Xbootclasspath` 参数所指定的路径中存放的，而且是 Java 虚拟机能够识别的类库) 加载到虚拟机的内存中，用于提供 JVM 自身需要的类。 
4. 并不继承自 `java.lang.ClassLoader`，没有父加载器
5. 加载拓展类和应用程序类加载器，并指定为他们的父类加载器
6. 处于安全考虑，Bootstrap 启动类加载器只加载包名为 java、javax、sun 等开头的类
简单来说，就是加载核心类库和其他类加载器。
#### 注意
用户在编写自定义类加载器时，如果需要把加载请求委托给启动类加载器去处理，那直接使用 null 代替即可。
下面是 `java.lang.Class.getClassLoader()` 方法的代码片段，其中的注释和代码实现都明确说明了以 null 值来代表启动类加载器的约定规则：
```java
@CallerSensitive  
@ForceInline // to ensure Reflection.getCallerClass optimization  
public ClassLoader getClassLoader() {  
    // 在这里，会去寻找类加载器，如果类加载器为空，则代表使用bootstrap类加载器，那么也会直接返回null  
    // 其实就是主要说明了大家都约定好使用null代表bootstrap类加载器  
 ClassLoader cl = getClassLoader0();  
    if (cl == null)  
        return null;  
    SecurityManager sm = System.getSecurityManager();  
    if (sm != null) {  
        ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());  
    }  
    return cl;  
}
```

### 虚拟机自带加载器
#### 拓展类加载器
1. Java 语言编写，由 `sun.misc.Launcher$ExtClassLoader` 实现。
2. 派生于 ClassLoader 类
3. 父类加载器为启动类加载器
4. 从 `java.ext.dirs` 系统属性所指定的目录中加载类库，或从 JDK 的安装目录的 `jre/lib/ext` 子目录（拓展目录）下加载类库。
注意：如果用户创建的 JAR 放在此目录下，也会自动由拓展类加载器加载。
理解：拓展类加载器就是负责加载除了核心包（核心包是由启动类加载器加载）之外的拓展类。

#### 应用程序类加载器（系统加载器、AppClassLoader）
1. Java 语言编写，由 `sun.misc.Launcher$AppClassLoader` 实现
2. 派生于 ClassLoader 类
3. 父类加载器为拓展类加载器
4. 它负责加载环境变量 classpath 或系统属性 `java.class.path` 指定路径下的类库
5. 该类加载器是程序中的默认类加载器，一般来说，Java 应用的类都是由它来完成加载
6. 通过 `ClassLoader#getSystemClassLoader()` 方法可以获取到该类加载器


# 双亲委派模型


<img src="https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20211217102609.png" width = "50%" />

上图展示的各种类加载器之间的层次关系被称为**双亲委派模型**。
双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里类加载器之间的父子一般不是用**继承**的关系来实现，而是通常使用**组合**关系来复用父加载器的代码。

