---
title: 3. 类加载的过程
tags: []
categories:
  - 编程语言
  - Java
  - Java语言
  - JVM
  - 7 虚拟机类加载机制
date: 2022-12-04 02:20:59
---



## 1. 加载

注意：这里的加载≠类加载，只是类加载的一个阶段。
在加载阶段，Java虚拟机需要完成以下三件事情：
1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。
3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。

注意：
这个阶段是最灵活的一个阶段，也是开发人员可控性最强的阶段。
例如“通过一个类的全限定名来获取定义此类的二进制字节流”这条规则.它并没有指明二进制字节流必须得从某个Class文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。仅仅这一点空隙，Java虚拟机的使用者们就可以在加载阶段搭构建出一个相当开放广阔的舞台，Java发展历程中，充满创造力的开发人员则在这个舞台上玩出了各种花样，许多举足轻重的Java技术都建立在这一基础之上，
- 例如最典型的从ZIP压缩包中读取，也就是日后JAR格式的基础。
- 从网络中获取
- 运行时计算生成，这种场景用的最多的就是动态代理技术。
- ...

加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员 通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass()或loadClass()方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。

也就是说，加载阶段完成之后，类加载器已经调用过loadClass方法来生成一个Class对象了（具体可以看[[Java反射浅析]])。

具体来说，加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，方法区中的数据存储格式完全由虚拟机实现自行定义，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.dass类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。

## 2. 验证
首先我们介绍一下连接阶段，这个阶段公共分为三个部分：
- 验证
- 准备
- 解析

解析阶段的目的是确保Class文件的字节流包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当成代码运行后不会危害虚拟机自身的安全。

验证阶段是非常重要的，这个阶段是否严谨，直接决定了Java虚拟机是否能承受恶意代码的攻击，从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重。

### 验证的几个阶段
1. 文件格式验证
2. 元数据验证
3. 字节码验证
4. 符号引用验证


## 3. 准备
准备阶段是正式为**类中定义的变量**（也就是静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。

从概念上讲，这些变量所使用的内存都应当在方法区中分配，但必须注意到方法区本身是一个逻辑上的区域，==在JDK8之后，类变量则会随着Class对象一起存放在Java堆中==，这时候”类变量在方法区“已经完全是一种对逻辑概念的表述了。具体可以参考（[[4 虚拟机性能监控、故障处理工具]]）。

关于准备阶段，还有两个需要注意的：

1. 在这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化的时候随着对象一起分配在Java堆中。
    也就是说，只有用static修饰的变量才会分配内存并且设置初始值，实例变量在对象实例化的时候才会进行内存的分配。
    更加具体来说。
   ```java
	public class A{
        public static int a = 123;
        public int b = 456;
    }
    ```
    对于这个类，被`static`修饰的变量`a`会在准备阶段被分配内存并且设置初始值(`0`)，但是没有被`static`修饰的变量`b`则不会在准备阶段被分配内存，只会在`new A()`的时候才会分配内存。
1. 这里所说的初始值，**通常情况下**是数据类型的零值。
    还是上面的例子，变量`a`在准备阶段之后的初始值是0而不是123，因为这时候尚未开始执行任何Java方法，而把value赋值为123的`putstatic`指令是程序被编译后，存放于类构造器`<clinit>()`之中，所以把`value`赋值为123的动作要到类的初始化阶段才会被执行。
	再次回忆我们这个图：
	<img src=https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20210810140918.png height=200>
	看到初始化在准备阶段之后，所以其不会那么快被赋值。

还需要注意的一点是，上面提到的是在“通常情况”下初始值是零值，也就是说会有一些“特殊情况”：如果类字段的字段属性表中存在ConstantValue属性，那在准备阶段变量值就会被初始化为ConstantValue属性所指定的初始值，假设上面的类变量`a`的定义修改为：

```java
public static final int value = 123;
```

编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为123。

## 4. 解析
解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程。

回忆一下符号引用，在第6章（[[6 类文件结构]]）讲解Class文件格式的时候就已经出现了很多次，在Class文件中它以CONSTANT_Class_info、CONSTANT_Methodref_info等类型的常量出现。

### 直接引用和符号引用的关系

#### 符号引用
符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。
符号引用与虚拟机的实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当众的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。

#### 直接引用
直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，要引用的目标必定已经在虚拟机的内存中存在。


### 解析的时机
《Java虚拟机规范》之中并未规定解析阶段发生的具体时间，只要求了在执行`anewarray`、`checkcast`、 `getfield`、`getstatic`、`instanceof`、`invokedynamic`、`invokeinterface`、`invokespecial`、`invokestatic`、`invokevirtual`、`Idc`、`ldc_w`、`ldc2_w`、`multianewarray`、`new`、`putfield` 和 `putstatic`这17个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所以虚拟机实现可以根据需要来**自行判断**，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。

对同一个符号引用进行多次解析请求是很常见的事情，除`invokedynamic`指令以外，虚拟机实现可以对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标识为已解析状态）从而避免解析动作重复进行。
**解释**：除了invokedynamic之外，其他情况下多次解析的结果是相同的，因此可以将常量标识为已解析状态并且记录在运行时常量池中，下次可以直接使用。

不过对于`invokedynamic`指令，上面的规则就不成立了。当碰到某个前面已经由`invokedynamic`指令触发过解析的符号引用时，并不意味着这个解析结果对于其他`invokedynamic`指令也同样生效。
因为`invokedynamic`指令的目的本来就是用于动态语言支持，它对应的引用称为“动态调用点限定符(Dynamically-Computed Call Site Specifier)”

#### 动态的含义：
“动态”的含义是指必须等到程序实际运行到这条指令时，解析动作才能进行。相对地，其余可触发解析的指令都是“静态”的，可以在刚刚完成加载阶段，还没有开始执行代码时就提前进行解析。

### 解析的对象和对应常量类型
解析动作主要针对类和接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符这7类符号引用进行，分别对应于常量池的的CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info、CONSTANT_InterfaceMethodref_info、CONSTANT_MethodType_info、 CONSTANT_MethodHandle_info, CONSTANT_Dynamic_info和CONSTANT_InvokeDynamic_info 8种常量类型。

### 解析过程
#### 1. 类和接口的解析
假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤： 
1. 如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败
2. 如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似`[Ljava/lang/Integer`的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是“java.lang.Integer”，接着由虚拟机生成一个代表该数组维度和元素的数组对象C
3. 如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出java.lang.IllegalAccessError异常，

总结一下，就是**先加载，然后检查访问权限**。

针对上面第3点访问权限验证，在JDK9引入了模块化以后，一个public类型也不再 意味着程序任何位置都有它的访问权限，我们还必须检查模块间的访问权限。
如果我们说一个D拥有C的访问权限，那就意味着以下3条规则中至少有其中一条成立：
- 被访问类C是public的，并且与访问类D处于同一个模块。
- 被访问类C是public的，不与访问类D处于同一个模块，但是被访问类C的模块 允许被访问类D的模块进行访问。
- 被访问类C不是public的，但是它与访问类D处于同一个包中。

#### 2. 字段解析
要解析一个未被解析过的字段符号引用，首先将会对字段表内`class_index`项中索引的`CONSTANT_Class_info`符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或接口符号引用的过程中出现了任何异常，都会导致字段符号引用解析的失败如果解析成功完成，那把这个字段所属的类或接口用`C`表示，《Java虚拟机规范》要求按照如下步骤对`C`进行后续字段的搜索：
1. 如果`C`本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返同这个字段的直接引用，查找结束。
2. 否则，如果在`C`中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
3. 否则，如果`C`不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。
4. 否则,查找失败，抛出 java.lang.NoSuchFieldError 异常。

如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出java.lang.IllegalAccessError异常。

以上解析规则能够确保Java虚拟机获得字段唯一的解析结果，但在实际情况中，Javac编译器往往会采取比上述规范更加严格一些的约束，譬如有一个同名字段同时出现在某个类的接口和父类当中，或者同时在自己或父类的多个接口中出现，按照解析规则仍是可以确定唯一的访问字段，但Javac编译器就可能直接拒绝其编译为Class文件。

```java
package com.coachhe.第4节_字段解析;

public class FieldResolution {
    interface Interface0{
        int A = 0;
    }

    interface Interface1 extends Interface0{
        int A = 1;
    }

    interface Interface2 {
        int A = 2;
    }

    static class Parent implements Interface1{
        public static int A = 3;
    }

    static class Sub extends Parent implements Interface2{
        public static int A = 4;
    }

    public static void main(String[] args) {
        System.out.println(Sub.A);
    }
}

```


#### 3. 方法解析
方法解析的第一个步骤与字段解析一样，也是需要先解析出方法表的`class_index`项中索引的方法所属的类或接口的符号引用，如果解析成功，那么我们依然用`C`表示这个类，接下来虚拟机将会按照如下步骤进行后续的方法搜索：
1. 由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的 ， 如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang. IncompatibleClassChangeError 异常。
2. 如果通过了第一步，在类C中查找是否有简单名称和描述符都与目标相匹配的方 法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法, 如果有则返回这个方法的直接引用，查找结束。
4. 否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述 符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结 束，抛出 java.lang.AbstractMethodError 异常。
5. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodErrorc

最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，将抛出java.lang.IllegalAccessError异常。

#### 4. 接口方法解析
接口方法也是需要先解析出接口方法表的`class_index`项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会按照如下步骤

1. 与类的方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出 java.lang.IncompatibleClassChangeError 异常。
2. 否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
3. 否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。
4. 对于规则3,由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，（Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。
5. 否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。



### 5. 初始化
类的初始化阶段是类加载过程的最后一个步骤，之前介绍的几个类加载的动作里，除了在加载阶段用户应用程序可以通过自定义类加载器的方式局部参与外，其余动作都完全由 Java 虚拟机来主导控制。直到初始化阶段，Java 虚拟机才真正开始执行类中编写的 Java 程序代码，将主导权移交给应用程序。

进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。我们也可以从另外一种更直接的形式来表达：
**初始化阶段就是执行类构造器 `<clinit＞()` 方法的过程。**

#### 注意：
`＜clinit＞()` 并不是程序员在 Java 代码中直接编写的方法，它是 Javac 编译器的自动生成物，但我们非常有必要了解这个方法具体是如何产生的，以及 `<clinit＞()` 方法执行过程中各种可能会影响程序运行行为的细节，这部分比起其他类加载过程更贴近于普通的程序开发人员的实际工作。

#### 1. Clinit 方法的产生
`<clinit>()` 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的
顺序：
编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，（这是因为在前面的准备阶段中已经赋予了一个初值，因此可以进一步进行赋值，但是不能访问，因为实际上还没有被创建出来) 但是不能访问。

##### 示例
```java
public class IllegalForwardReference {  
    /**  
     * 非法向前引用变量  
     * 在这里第一次打印i失败了，第二次打印i就成功了，这是因为在初始化过程中执行clinit方法，这个方法是顺序执行的，  
     * 第一次打印i时，还没有对i进行定义，因此打印失败了。  
     * 第二次打印i时，已经成功定义了，所以打印成功了  
     */  
    static {  
        i = 0; //给变量赋值是可以正常编译通过的  
//        System.out.println(i); //这句编译器会提示"非法向前引用",illegal forward reference  
    }  
    static int i = 1;  
    static {  
        System.out.println(i); // 在这里就可以正常使用i这个值了  
    }
}
```

#### 2. 父类构造器的执行
Java 虚拟机会保证在子类的 `<clinit>()` 方法执行前，父类的 `<clinit>()` 方法已经执行完毕。因此在 Java 虚拟机中第一个被执行的 `<clinit>()` 方法一定是 `java.lang.object`
父类的 `<clinit>()` 方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。
##### 示例
```java
/**  
 * clint方法执行顺序示例  
 */  
static class Parent {  
    public static int A = 1;  
    static {  
        A = 2;  
    }  
}  
static class Sub extends Parent {  
    public static int B = A;  
}  
public static void main(String[] args) {  
    // 在这里打印的是2，因为父类中的静态语句要优于子类的变量赋值操作  
 System.out.println(Sub.B);  
}
```

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20211213125423.png" width="50%">

#### 3.  `<clinit>()` 方法的必须性
 `<clinit>()` 方法不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成 `<clinit>()` 方法
 
#### 4.  `<clinit>()` 方法初始化加锁
Java 虚拟机必须要保证一个类的 `<clinit>()` 方法在多线程环境中被正确地加锁同步，如果多个线程同时去初始化一个类，那么只会有其中一个线程去执行这个类的 `<clinit>()` 方法，其他线程都需要阻塞等待，知道活动线程执行完毕 `<clinit>()` 方法。如果一个类的 `<clinit>()` 方法中有耗时很长的操作，那就可能造成多个进程阻塞。

##### 示例
```java

package com.coachhe.第5节_初始化;  
  
/**  
 * 当多个线程同时去初始化一个类时，只会有一个线程去执行这个类的<clinit>()方法，其他线程都需要阻塞等待  
 * 直到活动线程执行完毕<clinit>()方法。  
 * 因此，如果在一个类<clinit>()方法中有耗时很长的操作，那就可能造成多个进程阻塞  
 * 接下来进行展示：  
 */  
public class DeadLoopClass {  
    static class DealLoopClassTest {  
        static {  
            if (true) {  
                System.out.println(Thread.currentThread() + "init DeadLoopClass");  
                while (true) {  
                }  
            }  
        }  
    }  
  
    public static void main(String[] args) {  
        Runnable script = () -> {  
            System.out.println("Thread.currentThread() " + "start");  
            DealLoopClassTest dlc = new DealLoopClassTest();  
            System.out.println("Thread.currentThread() " + "run over");  
        };  
  
        Thread thread1 = new Thread(script);  
        Thread thread2 = new Thread(script);  
        thread1.start();  
        thread2.start();  
    }  
}
```

运行结果为：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20211213130235.png" width="50%">


