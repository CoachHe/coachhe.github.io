---
title: 1. 字符串概述
date: 2022-12-15 01:17:02  
tags: []  
---

# 1. 字符串的定义

字符串有两种定义方式：

```java
String s1 = "coachhe";
String s2 = new String("Hello");
```

# 2. 字符串的不可变性

- 当对字符串重新赋值时，需要重写指定区域赋值，不能使用原有的 `value` 进行赋值。
- 当对现有的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 `value` 进行赋值
- 当调用 `String` 的 `replace()` 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 `value` 进行赋值

先看对应的代码：

```java

```

这块很简单，直接看代码：

```java
/**  
 * @author CoachHe  
 * @date 2022/12/15 01:00  
 * 这里是为了展示Java字符串的不可变性，传入的其实是q对象引用的副本  
 **/  
public class Immutable {  
  
    public static String upcase(String s) {  
        return s.toUpperCase();  
    }  
  
    public static void main(String[] args) {  
        String q = "howdy";  
        System.out.println(q); //howdy  
        String qq = upcase(q);  
        System.out.println(qq); // HOWDY  
        System.out.println(q); // howdy  
    }  
  
}
```

在 `upcase()` 里，参数 `s` 值存活于这个方法的方法体中。

# 3. 字符串底层结构的变更

我们先来看看 `jdk8` 中字符串的底层结构：

```java
public final class String  
    implements java.io.Serializable, Comparable<String>, CharSequence {  
    /** The value is used for character storage. */  
    private final char value[];
    ...
}
```

可以看到，这里底层是用 `char` 数组来存储的。但是在 `jdk9` 之后就变了，我们来看个 `jdk11` 的：

```java
public final class String
    implements java.io.Serializable, Comparable<String>, CharSequence {

    /**
     * The value is used for character storage.
     *
     * @implNote This field is trusted by the VM, and is a subject to
     * constant folding if String instance is constant. Overwriting this
     * field after construction will cause problems.
     *
     * Additionally, it is marked with {@link Stable} to trust the contents
     * of the array. No other facility in JDK provides this functionality (yet).
     * {@link Stable} is safe here, because value is never null.
     */
    @Stable
    private final byte[] value;
    ...
}
```

可以看到，底层存储数据结构变为了 `byte` 数组，原因是因为原先一个 `char` 是两个 `byte`，但是在实际使用中发现其实大部分 `String` 对象都是拉丁字符，只需要一个 `byte`，因此使用 `char` 数组其实很浪费，因此更新为了 `byte` 数组。




