---
title: 2. 重载 + 与StringBuilder与intern
date: 2022-12-15 01:50:09  
tags: []  
---

在上一节 [[1. 字符串概述]]中我们知道，`String` 对象是不可变的，因此我们可以根据需要为特定的 `String` 设置多个别名。因为 `String` 是只读的，指向它的任何引用都不可能改变它的值，所以引用之间不会相互影响。

不可变性可能会带来效率问题。

# 字符串重载

一个典型的例子是操作符 `+`，它针对 `String` 对象做了重载。==操作符重载==意味着在与特定类一起使用时，相应的操作符具有额外的意义。（应用于 `String` 的 `+` 和 `+=` 是 Java 中仅有的被重载的操作符，Java 中不允许程序员重构其他操作符）

`+` 操作可以用来拼接字符串：

在进行之前我们先了解一下拼接的规则：

## 拼接的规则

1. 常量和常量的拼接结果在常量池，原理是编译器优化
2. 常量池中不会存在相同内容的变量
3. **只要其中有一个是变量，结果就在堆中**。变量拼接的原理是 `StringBuilder`
4. 如果拼接的结果调用 `intern()` 方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址

让我们慢慢来看，首先是上面第一条 : 常量和常量的拼接结果在常量池

```java
    // 证明常量拼接之后会通过编译器间优化放入常量池中
    @Test
    public void ConcatenationTest1(){
        String a = "abc";
        String b = "a" + "b" + "c";
        /**
         * 最终，java编译成.class，再执行.class
         * String a = "abc";
         * String b = "abc";
         */
        System.out.println(a == b); //true
        System.out.println(a.equals(b)); //true
    }
```

可以看到，判断 `a == b` 时输出的是 `true`，这是因为在编译期进行优化，可以看下编译之后的 class 文件反编译的结果：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221215024246.png" width = "70%" />

可以看到，编译期间进行了优化。

再看看第 3 条：**只要其中有一个是变量，结果就在堆中**。

```java
// 证明拼接时只要有一个变量，结果就会放入堆中  
@Test  
public void ConcatenationTest2(){  
    String s1 = "javaEE";  
    String s2 = "hadoop";  
  
    String s3 = "javaEEhadoop";  
    String s4 = "javaEE" + "hadoop";  
    String s5 = s1 + "hadoop";  
    String s6 = "javaEE" + s2;  
    String s7 = s1 + s2;  
  
    System.out.println(s3 == s4); // true  
    System.out.println(s3 == s5); // false  
    System.out.println(s3 == s6); // false  
    System.out.println(s3 == s7); // false  
    System.out.println(s5 == s6); // false  
    System.out.println(s5 == s7); // false  
    System.out.println(s6 == s7); // false  
  
    String s8 = s6.intern();  
    System.out.println(s3 == s8); // true  
}
```

可以看到，只要里面有个变量存在，这里都是会 new 一个对象，那么结果就不可能相同了。

但是最后调用 `intern` 方法之后，会将其放入字符串常量池，那么此时 `s3` 和 `s8` 就指向同一个对象了。

那么原理是 `StringBuilder` 怎么理解呢？

来看看下面这段代码：

```java
/**  
 * @author CoachHe  
 * @date 2022/12/15 02:37  
 **/public class Concatenation {  
    public static void main(String[] args) {  
        String mango = "mango";  
        String s = "abc" + mango + "def" + 47;  
        System.out.println(s);  
    }  
}
```

将其进行反汇编：

```java
 0 ldc #14 <mango>
 2 astore_1
 3 new #9 <java/lang/StringBuilder>
 6 dup
 7 invokespecial #10 <java/lang/StringBuilder.<init> : ()V>
10 ldc #2 <abc>
12 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
15 aload_1
16 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
19 ldc #15 <def>
21 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
24 bipush 47
26 invokevirtual #16 <java/lang/StringBuilder.append : (I)Ljava/lang/StringBuilder;>
29 invokevirtual #12 <java/lang/StringBuilder.toString : ()Ljava/lang/String;>
32 astore_2
33 getstatic #3 <java/lang/System.out : Ljava/io/PrintStream;>
36 aload_2
37 invokevirtual #17 <java/io/PrintStream.println : (Ljava/lang/String;)V>
40 return
```

进行分析，我们可以看到，首先从字符串常量池的第 14 个位置获取字符串常量 `mango` ，并将其放入本地变量表的第一个位置，注意，这里第 0 个位置是默认的输入参数 `args`，因为是静态方法所以没有 `this` 变量，具体的可以看 JVM 内容 [[8 虚拟机字节码执行引擎]]。

```java
 0 ldc #14 <mango>
 2 astore_1
```

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221215130047.png" width = "50%" />

然后 new 了一个 `StringBuilder` :

```java
 3 new #9 <java/lang/StringBuilder>
 6 dup
 7 invokespecial #10 <java/lang/StringBuilder.<init> : ()V>
```

具体细节可以看 [[7 虚拟机类加载机制]]

接着会从局部变量表中位置为 1 的方法加载进来。

```java
15 aload_1
```

然后调用 `StringBuilder` 的 `append` 方法，将栈帧顶部的局部变量表中的字符串 `mongo` append 进这个 `StringBuilder` 中，接着步骤也是相同的

```java
16 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
19 ldc #15 <def>
21 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
24 bipush 47
26 invokevirtual #16 <java/lang/StringBuilder.append : (I)Ljava/lang/StringBuilder;>
```

最后调用 `StringBuilder` 的 `toString` 方法，返回一个 `String` 对象，最后返回

```java
29 invokevirtual #12 <java/lang/StringBuilder.toString : ()Ljava/lang/String;>
32 astore_2
33 getstatic #3 <java/lang/System.out : Ljava/io/PrintStream;>
36 aload_2
37 invokevirtual #17 <java/io/PrintStream.println : (Ljava/lang/String;)V>
40 return
```

这就是代码的字节码层面的全部经过

所以这段代码等价于：

```java
String mango = "mango";  
StringBuilder s = new StringBuilder();  
s.append("abc");  
s.append(mango);  
s.append("def");  
s.append(47);  
System.out.println(s.toString());
```

注意：
- 字符串拼接操作时使用的不一定是 `StringBuilder`，如果拼接符号左右都是字符串常量或者常量引用，那么还是会使用编译器优化，结果放在字符串常量池中。
- 针对于 `final` 修饰类、方法和基本数据类型、引用数据类型的量的结构时，能使用 `final` 则尽量使用上

看下这个例子：

```java
// 为了说明用final声明的变量重载时不会自动使用new创建  
@Test  
public void ConcatenationTest3(){  
    final String s1 = "a";  
    final String s2 = "b";  
    String s3 = "ab";  
    String s4 = s1 + s2;  
    System.out.println(s3 == s4);//true  
}
```

可以看到，最终输出的还是 true，说明 s4 还是直接指向了字符串常量池。

# append 测试

来看段代码：

```java
    //  append测试，代表直接用StringBuilder效率更高  
    @Test  
    public void ConcatenationTest4(){  
        long start = System.currentTimeMillis();  
  
        int highLevel = 100000;  
  
//        method1(highLevel); //花费的时间为：4936  
        method2(highLevel); //花费的时间为：4  
  
        long end = System.currentTimeMillis();  
  
        System.out.println("花费的时间为：" + (end - start));  
    }  
  
    // 直接使用字符串拼接  
    public void method1(int highLevel) {  
        String src = "";  
        for (int i = 0; i < highLevel; i++) {  
            src = src + "a"; // 每次循环都会创建一个StringBuilder  
        }  
    }  
  
    // 使用StringBuilder的append操作  
    public void method2(int highLevel) {  
        // 只需要创建一个StringBuilder  
        StringBuilder src = new StringBuilder();  
        for (int i = 0; i < highLevel; i++) {  
            src.append("a");  
        }  
    }
```

可以看到，两个方法花费的时间分别为 4936 毫秒和 4 毫秒，效率差别非常大。

解释：
- 使用 `StringBuilder` 的 `append()` 方式，自始至终只创建了一个 `StringBuilder` 对象
- 使用 `String` 的字符串拼接方式，创建了多个 `StringBuilder`，速度比较慢。此外，由于内存中创建了较多的 `StringBuilder` 和 `String` 对象，内存占用更大，进行 GC 还需要额外的时间。

从字节码角度来看：

先看看 method1 的字节码：

```java
// method1
 0 ldc #23
 2 astore_2
 3 iconst_0
 4 istore_3
 5 iload_3
 6 iload_1
 7 if_icmpge 36 (+29)
10 new #9 <java/lang/StringBuilder>
13 dup
14 invokespecial #10 <java/lang/StringBuilder.<init> : ()V>
17 aload_2
18 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
21 ldc #14 <a>
23 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
26 invokevirtual #12 <java/lang/StringBuilder.toString : ()Ljava/lang/String;>
29 astore_2
30 iinc 3 by 1
33 goto 5 (-28)
36 return
```

可以看到，第 7 行和第 33 行构成了一个循环，每次循环的都会新建一个 `StringBuilder`，然后调用 `toString` 又会创建一个 `String` 对象。

再看看 method2 的字节码：

```java
 0 new #9 <java/lang/StringBuilder>
 3 dup
 4 invokespecial #10 <java/lang/StringBuilder.<init> : ()V>
 7 astore_2
 8 iconst_0
 9 istore_3
10 iload_3
11 iload_1
12 if_icmpge 28 (+16)
15 aload_2
16 ldc #14 <a>
18 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
21 pop
22 iinc 3 by 1
25 goto 10 (-15)
28 return
```

可以看到，第 12 行和第 25 行构成了一个循环，在循环中没有新对象的生成，只调用了 `append()` 方法。因此效率会比 method1 好很多。

## 优化方案

如果一开始可以预估 `StringBuilder` 的长度，可以预先设置好，避免频繁进行扩容。

# toString() 的技巧

通常我们不会去动 `toString()` 方法，当创建 `toString()` 方法时，如果操作很简单，通常可以依赖编译器，让它以合理的方式自行构建结果。但如果涉及循环，并且对性能也有一定要求，那就需要再 `toString` 中显式使用 `StringBuilder` 了。

#  intern 方法

## 官方解释

Returns a canonical representation for the string object.
A pool of strings, initially empty, is maintained privately by the class String.
When the intern method is invoked, if the pool already contains a string equal to this String object as determined by the equals (Object) method, then the string from the pool is returned. Otherwise, this String object is added to the pool and a reference to this String object is returned.
It follows that for any two strings s and t, `s.intern() == t.intern()` is true if and only if `s.equals(t)` is true.
All literal strings and string-valued constant expressions are interned. String literals are defined in section 3.10.5 of the The Java™ Language Specification.
Returns:
a string that has the same contents as this string, but is guaranteed to be from a pool of unique strings.

简单来说，就是调用 `intern()` 方法的时候，如果字符串常量池中有一个调用 `equals` 方法返回 `true` 的字符串，那么会直接返回字符串常量池中的字符串。否则会将 `string` 对象放入字符串常量池，然后将 `reference` 返回。

并且当前仅当 `s.equals(t)` 时 `s.intern() == t.intern()`

## intern () 的使用（jdk6 vs jdk7/8）

如果不是用双引号声明的 `String` 对象，可以使用 `String` 提供的 `intern` 方法： `intern` 方法会从字符串常量池中查询当前字符串是否存在，若不存在就会将当前字符串放入常量池中。

也就是说，如果在任何字符串上调用 `String.intern()` 方法，那么其返回结果所指向的那个类实例，必须和直接以常量形式出现的字符串实例完全相同。

## `new String` 时会创建几个对象

这个问题其实可以分为两个子问题：

1.  `new String("ab")` 会创建几个对象
2. `new String("a") + new String("b")` 会创建几个对象

首先来看第一个问题：

###  `new String("ab")` 会创建几个对象

这个问题其实应该很简单，一定会创建两个
1. 在字符串常量池中放入一个 `"ab"` 字符串
2. `new` 的这个对象，在堆中。

那么深入思考一下，你怎么证明这件事呢？

答案： 看**字节码**！

这里我们先看源代码：

```java
/**  
 * @author CoachHe  
 * @date 2022/12/16 00:04  
 **/public class NewString {  
    public static void main(String[] args) {  
        String str = new String("ab");  
    }  
}
```

非常简单，就是 `new` 了一个 `String` 类型变量。那么来看他的字节码：

```java
 0 new #2 <java/lang/String>
 3 dup
 4 ldc #3 <ab>
 6 invokespecial #4 <java/lang/String.<init> : (Ljava/lang/String;)V>
 9 astore_1
10 return
```

可以看到，首先 `new` 了一个 `String` 对象，然后通过 `4 ldc #3 <ab>` 创建了一个常量池中的对象。一共两个对象。

那么此时我们可以来回答第二个问题：

### `new String("a") + new String("b")` 会创建几个对象

同样的，我们可以来看它的字节码：

源代码同样很简单：

```java
/**
 * @author CoachHe
 * @date 2022/12/16 00:04
 **/
public class NewString {
    public static void main(String[] args) {
//        String str = new String("ab");
        String str = new String("a") + new String("b");
    }
}
```

然后看其字节码：

```java
 0 new #2 <java/lang/StringBuilder>
 3 dup
 4 invokespecial #3 <java/lang/StringBuilder.<init> : ()V>
 7 new #4 <java/lang/String>
10 dup
11 ldc #5 <a>
13 invokespecial #6 <java/lang/String.<init> : (Ljava/lang/String;)V>
16 invokevirtual #7 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
19 new #4 <java/lang/String>
22 dup
23 ldc #8 <b>
25 invokespecial #6 <java/lang/String.<init> : (Ljava/lang/String;)V>
28 invokevirtual #7 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
31 invokevirtual #9 <java/lang/StringBuilder.toString : ()Ljava/lang/String;>
34 astore_1
35 return
```

可以看到，首先是 `new` 了一个 `StringBuilder`，然后 `new` 了字符串 `"a"` 对应的 ` String ` 对象，然后在里面调用了 ` StringBuilder ` 的 ` append ` 方法，然后 `new` 了字符串 `"b"` 对应的`S't`


