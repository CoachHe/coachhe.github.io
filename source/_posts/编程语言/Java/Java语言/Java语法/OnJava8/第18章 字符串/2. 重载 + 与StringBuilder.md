---
title: 2. 重载 + 与StringBuilder  
date: 2022-12-15 01:50:09  
tags: []  
---

在上一节 [[1. 字符串概述]]中我们知道，`String` 对象是不可变的，因此我们可以根据需要为特定的 `String` 设置多个别名。因为 `String` 是只读的，指向它的任何引用都不可能改变它的值，所以引用之间不会相互影响。

不可变性可能会带来效率问题。

# 字符串重载

一个典型的例子是操作符 `+`，它针对 `String` 对象做了重载。==操作符重载==意味着在与特定类一起使用时，相应的操作符具有额外的意义。（应用于 `String` 的 `+` 和 `+=` 是 Java 中仅有的被重载的操作符，Java 中不允许程序员重构其他操作符）

`+` 操作可以用来拼接字符串：

在进行之前我们先了解一下拼接的规则：

## 拼接的规则

1. 常量和常量的拼接结果在常量池，原理是编译器优化
2. 常量池中不会存在相同内容的变量
3. **只要其中有一个是变量，结果就在堆中**。变量拼接的原理是 `StringBuilder`
4. 如果拼接的结果调用 `intern()` 方法，则主动将常量池中还没有的字符串对象放入池中，并返回此对象地址

让我们慢慢来看，首先是上面第一条 : 常量和常量的拼接结果在常量池

```java
    // 证明常量拼接之后会通过编译器间优化放入常量池中
    @Test
    public void ConcatenationTest1(){
        String a = "abc";
        String b = "a" + "b" + "c";
        /**
         * 最终，java编译成.class，再执行.class
         * String a = "abc";
         * String b = "abc";
         */
        System.out.println(a == b); //true
        System.out.println(a.equals(b)); //true
    }
```

可以看到，判断 `a == b` 时输出的是 `true`，这是因为在编译期进行优化，可以看下编译之后的 class 文件反编译的结果：

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221215024246.png" width = "70%" />

可以看到，编译期间进行了优化。

再看看第 3 条：**只要其中有一个是变量，结果就在堆中**。

```java
// 证明拼接时只要有一个变量，结果就会放入堆中  
@Test  
public void ConcatenationTest2(){  
    String s1 = "javaEE";  
    String s2 = "hadoop";  
  
    String s3 = "javaEEhadoop";  
    String s4 = "javaEE" + "hadoop";  
    String s5 = s1 + "hadoop";  
    String s6 = "javaEE" + s2;  
    String s7 = s1 + s2;  
  
    System.out.println(s3 == s4); // true  
    System.out.println(s3 == s5); // false  
    System.out.println(s3 == s6); // false  
    System.out.println(s3 == s7); // false  
    System.out.println(s5 == s6); // false  
    System.out.println(s5 == s7); // false  
    System.out.println(s6 == s7); // false  
  
    String s8 = s6.intern();  
    System.out.println(s3 == s8); // true  
}
```

可以看到，只要里面有个变量存在，这里都是会 new 一个对象，那么结果就不可能相同了。

但是最后调用 `intern` 方法之后，会将其放入字符串常量池，那么此时 `s3` 和 `s8` 就指向同一个对象了。

那么原理是 `StringBuilder` 怎么理解呢？

来看看下面这段代码：

```java
/**  
 * @author CoachHe  
 * @date 2022/12/15 02:37  
 **/public class Concatenation {  
    public static void main(String[] args) {  
        String mango = "mango";  
        String s = "abc" + mango + "def" + 47;  
        System.out.println(s);  
    }  
}
```

将其进行反汇编：

```java
 0 ldc #14 <mango>
 2 astore_1
 3 new #9 <java/lang/StringBuilder>
 6 dup
 7 invokespecial #10 <java/lang/StringBuilder.<init> : ()V>
10 ldc #2 <abc>
12 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
15 aload_1
16 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
19 ldc #15 <def>
21 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
24 bipush 47
26 invokevirtual #16 <java/lang/StringBuilder.append : (I)Ljava/lang/StringBuilder;>
29 invokevirtual #12 <java/lang/StringBuilder.toString : ()Ljava/lang/String;>
32 astore_2
33 getstatic #3 <java/lang/System.out : Ljava/io/PrintStream;>
36 aload_2
37 invokevirtual #17 <java/io/PrintStream.println : (Ljava/lang/String;)V>
40 return
```

进行分析，我们可以看到，首先从字符串常量池的第 14 个位置获取字符串常量 `mango` ，并将其放入本地变量表的第一个位置，注意，这里第 0 个位置是默认的输入参数 `args`，因为是静态方法所以没有 `this` 变量，具体的可以看 JVM 内容 [[8 虚拟机字节码执行引擎]]。

```java
 0 ldc #14 <mango>
 2 astore_1
```

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/Redis/20221215130047.png" width = "50%" />

然后 new 了一个 `StringBuilder` :

```java
 3 new #9 <java/lang/StringBuilder>
 6 dup
 7 invokespecial #10 <java/lang/StringBuilder.<init> : ()V>
```

具体细节可以看 [[7 虚拟机类加载机制]]

接着会从局部变量表中位置为 1 的方法加载进来。

```java
15 aload_1
```

然后调用 `StringBuilder` 的 `append` 方法，将栈帧顶部的局部变量表中的字符串 `mongo` append 进这个 `StringBuilder` 中，接着步骤也是相同的

```java
16 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
19 ldc #15 <def>
21 invokevirtual #11 <java/lang/StringBuilder.append : (Ljava/lang/String;)Ljava/lang/StringBuilder;>
24 bipush 47
26 invokevirtual #16 <java/lang/StringBuilder.append : (I)Ljava/lang/StringBuilder;>
```

最后调用 `StringBuilder` 的 `toString` 方法，返回一个 `String` 对象，最后返回

```java
29 invokevirtual #12 <java/lang/StringBuilder.toString : ()Ljava/lang/String;>
32 astore_2
33 getstatic #3 <java/lang/System.out : Ljava/io/PrintStream;>
36 aload_2
37 invokevirtual #17 <java/io/PrintStream.println : (Ljava/lang/String;)V>
40 return
```

这就是代码的字节码层面的全部经过

所以这段代码等价于：

```java
String mango = "mango";  
StringBuilder s = new StringBuilder();  
s.append("abc");  
s.append(mango);  
s.append("def");  
s.append(47);  
System.out.println(s.toString());
```

注意：
- 字符串拼接操作时使用的不一定是 `StringBuilder`，如果拼接符号左右都是字符串常量或者常量引用，那么还是会使用编译器优化，结果放在字符串常量池中。
- 针对于 `final` 修饰类、方法和基本数据类型、引用数据类型的量的结构时，能使用 `final` 则尽量使用上

看下这个例子：

```java
// 为了说明用final声明的变量重载时不会自动使用new创建  
@Test  
public void ConcatenationTest3(){  
    final String s1 = "a";  
    final String s2 = "b";  
    String s3 = "ab";  
    String s4 = s1 + s2;  
    System.out.println(s3 == s4);//true  
}
```

可以看到，最终输出的还是 true，说明 s4 还是直接指向了字符串常量池。

# append 测试

来看段代码：

```java
    //  append测试，代表直接用StringBuilder效率更高  
    @Test  
    public void ConcatenationTest4(){  
        long start = System.currentTimeMillis();  
  
        int highLevel = 100000;  
  
//        method1(highLevel); //花费的时间为：4936  
        method2(highLevel); //花费的时间为：4  
  
        long end = System.currentTimeMillis();  
  
        System.out.println("花费的时间为：" + (end - start));  
    }  
  
    // 直接使用字符串拼接  
    public void method1(int highLevel) {  
        String src = "";  
        for (int i = 0; i < highLevel; i++) {  
            src = src + "a"; // 每次循环都会创建一个StringBuilder  
        }  
    }  
  
    // 使用StringBuilder的append操作  
    public void method2(int highLevel) {  
        // 只需要创建一个StringBuilder  
        StringBuilder src = new StringBuilder();  
        for (int i = 0; i < highLevel; i++) {  
            src.append("a");  
        }  
    }
```

可以看到，两个方法花费的时间分别为 4936 毫秒和 4 毫秒，效率差别非常大。

解释：
- 使用 `StringBuilder` 的 `append()` 方式，自始至终只创建了一个 `StringBuilder` 对象
- 使用 `String` 的字符串拼接方式，创建了多个 `StringBuilder`，速度比较慢。此外，由于内存中创建了较多的 `StringBuilder` 和 `String` 对象，内存占用更大，进行 GC 还需要额外的时间。

优化方案：
如果一开始可以预估 `StringBuilder` 的长度，可以预先设置好，避免频繁进行扩容。







