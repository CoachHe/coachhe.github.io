# 1. 为什么使用 `lambda` 表达式

## `lambda` 表达式定义

`lambda` 表达式是一个**可传递的代码块**，可以在以后执行一次或多次。

## 使用 `lambda` 表达式的场景

例如我们在 [[1. 接口]]中 ==接口与回调== 提过的 `swing` 中的 `Timer` 类，回忆一下：

```java
/**  
 * @author CoachHe  
 * @date 2022/12/8 01:28  
 **/
 public class TimeTest {  
  
    public static void main(String[] args) throws InterruptedException {  
        System.out.println("Begin");  
        TimePrinter listener = new TimePrinter();  
        Timer t = new Timer(1000, listener);  
        t.start();  
  
        // keep program running until the user select "OK"  
        JOptionPane.showMessageDialog(null, "Quit program?");  
        System.exit(0);  
    }  
}  
  
class TimePrinter implements ActionListener {  
    @Override  
    public void actionPerformed(ActionEvent e) {  
        System.out.println("At the tone, the time is "  
                + Instant.ofEpochMilli(e.getWhen()));  
        Toolkit.getDefaultToolkit().beep();  
    }  
}
```

可以看到，`Timer t = new Timer(1000, listener);` 中调用了 `TimePrinter` 类的实例，然后将该实例提交给了 `Timer` 对象。因为 `Timer` 对象的输入参数就是一个 `ActionListener` 接口类型的对象，所以我们不得不专门创建一个类来实现该接口，这其实是比较不方便的。

在很多语言中，可以直接处理代码块。为了支持函数式变成，设计者们设计了 `lambda` 表达式，让我们可以使用简便的**代码块方式**进行传入。

# 2. `lambda` 表达式的语法

`lambda` 表达式就是一个代码块，以及必须传入代码的变量规范。

例如我们要传入代码来检查一个字符串是否比另一个字符串短。这里要计算：

```java
(String first, String second) -> first.length() - second.length()
```

因此 `lambda` 表达式的语法如下：

==参数，箭头 (->) 以及一个表达式==。

1. 参数

注意，这里的参数一定要用括号包起来，即使 `lambda` 表达式没有参数，仍然要提供空括号，就像无参数方法一样：

```java
() -> System.out.print(1)
```

2. 箭头

这没啥好说的

3. 表达式

如果代码要完成的计算可以放在一个表达式里，那么直接写，就像上面参数中给的例子一样。如果代码要完成的计算无法在一个表达式里写完，那么把这些代码放在 `{}` 中。并包含显式的 `return` 语句。


我们不难知道，因为 `ActionListener` 中只有 `actionPerformed` 这一个方法，所以其实 `Timer` 中需要的仅仅是 `actionPerformed` 中包含的执行代码。因此 `lambda` 表达式的作用其实就是只将执行代码传入，然后会自动生成对应的对象实例，从而避免大量的重复工作。

# 3. 函数式接口

对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个 `lambda` 表达式。这种接口称为函数式接口。

例如，我们来看 `Arrays.sort` 方法。它的第二个参数需要一个 `Comparator` 实例，`Comparator` 就是只有一个方法的接口，所以可以提供一个 `lambda` 表达式：

我们先来看不使用 `lambda` 表达式的方式：

```java
/**  
 * @author CoachHe  
 * @date 2022/12/9 00:14  
 **/
 public class FunctionalInterfaceTest {  
    public static void main(String[] args) {  
        String[] arr = new String[]{"abc", "efc", "fslaf", "abcded"};  
        Arrays.sort(arr, new Comparator<String>() {  
            @Override  
            public int compare(String o1, String o2) {  
                return o1.length() - o2.length();  
            }  
        });  
    }  
}
```

我们可以看到，必须 `new` 一个 `Comparator` 对象，在对象里实现 `compare` 方法，然后 `Arrays.sort()` 方法会根据 `compare` 方法来比较大小，从而将 `arr` 数组按照字母的长度从左到右排序。

这里是可以使用 `lambda` 表达式进行替换的，原因是 `Comparator` 接口是只有一个抽象方法的接口，我们可以看到：

```java
@FunctionalInterface  
public interface Comparator<T> {  
    int compare(T o1, T o2);  
    boolean equals(Object obj);  
    default Comparator<T> reversed() {  
        return Collections.reverseOrder(this);  
    }  
    default Comparator<T> thenComparing(Comparator<? super T> other) {  
        Objects.requireNonNull(other);  
        return (Comparator<T> & Serializable) (c1, c2) -> {  
            int res = compare(c1, c2);  
            return (res != 0) ? res : other.compare(c1, c2);  
        };  
    }  
    default <U> Comparator<T> thenComparing(  
            Function<? super T, ? extends U> keyExtractor,  
            Comparator<? super U> keyComparator)  
    {  
        return thenComparing(comparing(keyExtractor, keyComparator));  
    }  
    default <U extends Comparable<? super U>> Comparator<T> thenComparing(  
            Function<? super T, ? extends U> keyExtractor)  
    {  
        return thenComparing(comparing(keyExtractor));  
    }  
    default Comparator<T> thenComparingInt(ToIntFunction<? super T> keyExtractor) {  
        return thenComparing(comparingInt(keyExtractor));  
    }  
    default Comparator<T> thenComparingLong(ToLongFunction<? super T> keyExtractor) {  
        return thenComparing(comparingLong(keyExtractor));  
    }  
  
    /**  
     * Returns a lexicographic-order comparator with a function that     * extracts a {@code double} sort key.  
     *     * @implSpec This default implementation behaves as if {@code  
     *           thenComparing(comparingDouble(keyExtractor))}.  
     *     * @param  keyExtractor the function used to extract the double sort key  
     * @return a lexicographic-order comparator composed of this and then the  
     *         {@code double} sort key  
     * @throws NullPointerException if the argument is null.  
     * @see #comparingDouble(ToDoubleFunction)  
     * @see #thenComparing(Comparator)  
     * @since 1.8  
     */    default Comparator<T> thenComparingDouble(ToDoubleFunction<? super T> keyExtractor) {  
        return thenComparing(comparingDouble(keyExtractor));  
    }  
  
    /**  
     * Returns a comparator that imposes the reverse of the <em>natural  
     * ordering</em>.  
     *     * <p>The returned comparator is serializable and throws {@link  
     * NullPointerException} when comparing {@code null}.  
     *     * @param  <T> the {@link Comparable} type of element to be compared  
     * @return a comparator that imposes the reverse of the <i>natural  
     *         ordering</i> on {@code Comparable} objects.  
     * @see Comparable  
     * @since 1.8  
     */    public static <T extends Comparable<? super T>> Comparator<T> reverseOrder() {  
        return Collections.reverseOrder();  
    }  
  
    /**  
     * Returns a comparator that compares {@link Comparable} objects in natural  
     * order.     *     * <p>The returned comparator is serializable and throws {@link  
     * NullPointerException} when comparing {@code null}.  
     *     * @param  <T> the {@link Comparable} type of element to be compared  
     * @return a comparator that imposes the <i>natural ordering</i> on {@code  
     *         Comparable} objects.  
     * @see Comparable  
     * @since 1.8  
     */    @SuppressWarnings("unchecked")  
    public static <T extends Comparable<? super T>> Comparator<T> naturalOrder() {  
        return (Comparator<T>) Comparators.NaturalOrderComparator.INSTANCE;  
    }  
  
    /**  
     * Returns a null-friendly comparator that considers {@code null} to be  
     * less than non-null. When both are {@code null}, they are considered  
     * equal. If both are non-null, the specified {@code Comparator} is used  
     * to determine the order. If the specified comparator is {@code null},  
     * then the returned comparator considers all non-null values to be equal.     *     * <p>The returned comparator is serializable if the specified comparator  
     * is serializable.     *     * @param  <T> the type of the elements to be compared  
     * @param  comparator a {@code Comparator} for comparing non-null values  
     * @return a comparator that considers {@code null} to be less than  
     *         non-null, and compares non-null objects with the supplied     *         {@code Comparator}.  
     * @since 1.8  
     */    public static <T> Comparator<T> nullsFirst(Comparator<? super T> comparator) {  
        return new Comparators.NullComparator<>(true, comparator);  
    }  
  
    /**  
     * Returns a null-friendly comparator that considers {@code null} to be  
     * greater than non-null. When both are {@code null}, they are considered  
     * equal. If both are non-null, the specified {@code Comparator} is used  
     * to determine the order. If the specified comparator is {@code null},  
     * then the returned comparator considers all non-null values to be equal.     *     * <p>The returned comparator is serializable if the specified comparator  
     * is serializable.     *     * @param  <T> the type of the elements to be compared  
     * @param  comparator a {@code Comparator} for comparing non-null values  
     * @return a comparator that considers {@code null} to be greater than  
     *         non-null, and compares non-null objects with the supplied     *         {@code Comparator}.  
     * @since 1.8  
     */    public static <T> Comparator<T> nullsLast(Comparator<? super T> comparator) {  
        return new Comparators.NullComparator<>(false, comparator);  
    }  
  
    /**  
     * Accepts a function that extracts a sort key from a type {@code T}, and  
     * returns a {@code Comparator<T>} that compares by that sort key using  
     * the specified {@link Comparator}.  
      *     * <p>The returned comparator is serializable if the specified function  
     * and comparator are both serializable.     *     * @apiNote  
     * For example, to obtain a {@code Comparator} that compares {@code  
     * Person} objects by their last name ignoring case differences,  
     *     * <pre>{@code  
     *     Comparator<Person> cmp = Comparator.comparing(  
     *             Person::getLastName,     *             String.CASE_INSENSITIVE_ORDER);     * }</pre>  
     *  
     * @param  <T> the type of element to be compared  
     * @param  <U> the type of the sort key  
     * @param  keyExtractor the function used to extract the sort key  
     * @param  keyComparator the {@code Comparator} used to compare the sort key  
     * @return a comparator that compares by an extracted key using the  
     *         specified {@code Comparator}  
     * @throws NullPointerException if either argument is null  
     * @since 1.8  
     */    public static <T, U> Comparator<T> comparing(  
            Function<? super T, ? extends U> keyExtractor,  
            Comparator<? super U> keyComparator)  
    {  
        Objects.requireNonNull(keyExtractor);  
        Objects.requireNonNull(keyComparator);  
        return (Comparator<T> & Serializable)  
            (c1, c2) -> keyComparator.compare(keyExtractor.apply(c1),  
                                              keyExtractor.apply(c2));  
    }  
  
    /**  
     * Accepts a function that extracts a {@link java.lang.Comparable  
     * Comparable} sort key from a type {@code T}, and returns a {@code  
     * Comparator<T>} that compares by that sort key.  
     *     * <p>The returned comparator is serializable if the specified function  
     * is also serializable.     *     * @apiNote  
     * For example, to obtain a {@code Comparator} that compares {@code  
     * Person} objects by their last name,  
     *     * <pre>{@code  
     *     Comparator<Person> byLastName = Comparator.comparing(Person::getLastName);  
     * }</pre>  
     *  
     * @param  <T> the type of element to be compared  
     * @param  <U> the type of the {@code Comparable} sort key  
     * @param  keyExtractor the function used to extract the {@link  
     *         Comparable} sort key  
     * @return a comparator that compares by an extracted key  
     * @throws NullPointerException if the argument is null  
     * @since 1.8  
     */    public static <T, U extends Comparable<? super U>> Comparator<T> comparing(  
            Function<? super T, ? extends U> keyExtractor)  
    {  
        Objects.requireNonNull(keyExtractor);  
        return (Comparator<T> & Serializable)  
            (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));  
    }  
  
    /**  
     * Accepts a function that extracts an {@code int} sort key from a type  
     * {@code T}, and returns a {@code Comparator<T>} that compares by that  
     * sort key.     *     * <p>The returned comparator is serializable if the specified function  
     * is also serializable.     *     * @param  <T> the type of element to be compared  
     * @param  keyExtractor the function used to extract the integer sort key  
     * @return a comparator that compares by an extracted key  
     * @see #comparing(Function)  
     * @throws NullPointerException if the argument is null  
     * @since 1.8  
     */    public static <T> Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor) {  
        Objects.requireNonNull(keyExtractor);  
        return (Comparator<T> & Serializable)  
            (c1, c2) -> Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));  
    }  
  
    /**  
     * Accepts a function that extracts a {@code long} sort key from a type  
     * {@code T}, and returns a {@code Comparator<T>} that compares by that  
     * sort key.     *     * <p>The returned comparator is serializable if the specified function is  
     * also serializable.     *     * @param  <T> the type of element to be compared  
     * @param  keyExtractor the function used to extract the long sort key  
     * @return a comparator that compares by an extracted key  
     * @see #comparing(Function)  
     * @throws NullPointerException if the argument is null  
     * @since 1.8  
     */    public static <T> Comparator<T> comparingLong(ToLongFunction<? super T> keyExtractor) {  
        Objects.requireNonNull(keyExtractor);  
        return (Comparator<T> & Serializable)  
            (c1, c2) -> Long.compare(keyExtractor.applyAsLong(c1), keyExtractor.applyAsLong(c2));  
    }  
  
    /**  
     * Accepts a function that extracts a {@code double} sort key from a type  
     * {@code T}, and returns a {@code Comparator<T>} that compares by that  
     * sort key.     *     * <p>The returned comparator is serializable if the specified function  
     * is also serializable.     *     * @param  <T> the type of element to be compared  
     * @param  keyExtractor the function used to extract the double sort key  
     * @return a comparator that compares by an extracted key  
     * @see #comparing(Function)  
     * @throws NullPointerException if the argument is null  
     * @since 1.8  
     */    public static<T> Comparator<T> comparingDouble(ToDoubleFunction<? super T> keyExtractor) {  
        Objects.requireNonNull(keyExtractor);  
        return (Comparator<T> & Serializable)  
            (c1, c2) -> Double.compare(keyExtractor.applyAsDouble(c1), keyExtractor.applyAsDouble(c2));  
    }  
}
```


# 4. 方法引用

如果可以直接将方法传递到某个构造器中就方便很多了。
