# 1. 为什么使用 `lambda` 表达式

## `lambda` 表达式定义

`lambda` 表达式是一个**可传递的代码块**，可以在以后执行一次或多次。

## 使用 `lambda` 表达式的场景

例如我们在 [[1. 接口]]中 ==接口与回调== 提过的 `swing` 中的 `Timer` 类，回忆一下：

```java
/**  
 * @author CoachHe  
 * @date 2022/12/8 01:28  
 **/
 public class TimeTest {  
  
    public static void main(String[] args) throws InterruptedException {  
        System.out.println("Begin");  
        TimePrinter listener = new TimePrinter();  
        Timer t = new Timer(1000, listener);  
        t.start();  
  
        // keep program running until the user select "OK"  
        JOptionPane.showMessageDialog(null, "Quit program?");  
        System.exit(0);  
    }  
}  
  
class TimePrinter implements ActionListener {  
    @Override  
    public void actionPerformed(ActionEvent e) {  
        System.out.println("At the tone, the time is "  
                + Instant.ofEpochMilli(e.getWhen()));  
        Toolkit.getDefaultToolkit().beep();  
    }  
}
```

可以看到，`Timer t = new Timer(1000, listener);` 中调用了 `TimePrinter` 类的实例，然后将该实例提交给了 `Timer` 对象。因为 `Timer` 对象的输入参数就是一个 `ActionListener` 接口类型的对象，所以我们不得不专门创建一个类来实现该接口，这其实是比较不方便的。

在很多语言中，可以直接处理代码块。为了支持函数式变成，设计者们设计了 `lambda` 表达式，让我们可以使用简便的**代码块方式**进行传入。

# 2. `lambda` 表达式的语法

`lambda` 表达式就是一个代码块，以及必须传入代码的变量规范。

例如我们要传入代码来检查一个字符串是否比另一个字符串短。这里要计算：

```java
(String first, String second) -> first.length() - second.length()
```

因此 `lambda` 表达式的语法如下：

==参数，箭头 (->) 以及一个表达式==。

1. 参数

注意，这里的参数一定要用括号包起来，即使 `lambda` 表达式没有参数，仍然要提供空括号，就像无参数方法一样：

```java
() -> System.out.print(1)
```

2. 箭头

这没啥好说的

3. 表达式

如果代码要完成的计算可以放在一个表达式里，那么直接写，就像上面参数中给的例子一样。如果代码要完成的计算无法在一个表达式里写完，那么把这些代码放在 `{}` 中。并包含显式的 `return` 语句。


我们不难知道，因为 `ActionListener` 中只有 `actionPerformed` 这一个方法，所以其实 `Timer` 中需要的仅仅是 `actionPerformed` 中包含的执行代码。因此 `lambda` 表达式的作用其实就是只将执行代码传入，然后会自动生成对应的对象实例，从而避免大量的重复工作。

# 3. 函数式接口

对于只有一个抽象方法的接口，需要这种接口的对象时，就可以提供一个 `lambda` 表达式。这种接口称为函数式接口。

例如，我们来看 `Arrays.sort` 方法。它的第二个参数需要一个 `Comparator` 实例，`Comparator` 就是只有一个方法的接口，所以可以提供一个 `lambda` 表达式：

我们先来看不使用 `lambda` 表达式的方式：

```java
/**  
 * @author CoachHe  
 * @date 2022/12/9 00:14  
 **/
 public class FunctionalInterfaceTest {  
    public static void main(String[] args) {  
        String[] arr = new String[]{"abc", "efc", "fslaf", "abcded"};  
        Arrays.sort(arr, new Comparator<String>() {  
            @Override  
            public int compare(String o1, String o2) {  
                return o1.length() - o2.length();  
            }  
        });  
    }  
}
```

我们可以看到，必须 `new` 一个 `Comparator` 对象，在对象里实现 `compare` 方法，然后 `Arrays.sort()` 方法会根据 `compare` 方法来比较大小，从而将 `arr` 数组按照字母的长度从左到右排序。

这里是可以使用 `lambda` 表达式进行替换的，原因是 `Comparator` 接口是只有一个抽象方法的接口，我们可以看到：

```java
@FunctionalInterface  
public interface Comparator<T> {  
    /**  
     * Compares its two arguments for order.  Returns a negative integer,     * zero, or a positive integer as the first argument is less than, equal     * to, or greater than the second.<p>  
     *  
     * The implementor must ensure that {@code sgn(compare(x, y)) ==  
     * -sgn(compare(y, x))} for all {@code x} and {@code y}.  (This  
     * implies that {@code compare(x, y)} must throw an exception if and only  
     * if {@code compare(y, x)} throws an exception.)<p>  
     *  
     * The implementor must also ensure that the relation is transitive:     * {@code ((compare(x, y)>0) && (compare(y, z)>0))} implies  
     * {@code compare(x, z)>0}.<p>  
     *  
     * Finally, the implementor must ensure that {@code compare(x, y)==0}  
     * implies that {@code sgn(compare(x, z))==sgn(compare(y, z))} for all  
     * {@code z}.<p>  
     *  
     * It is generally the case, but <i>not</i> strictly required that  
     * {@code (compare(x, y)==0) == (x.equals(y))}.  Generally speaking,  
     * any comparator that violates this condition should clearly indicate     * this fact.  The recommended language is "Note: this comparator     * imposes orderings that are inconsistent with equals."<p>  
     *  
     * In the foregoing description, the notation     * {@code sgn(}<i>expression</i>{@code )} designates the mathematical  
     * <i>signum</i> function, which is defined to return one of {@code -1},  
     * {@code 0}, or {@code 1} according to whether the value of  
     * <i>expression</i> is negative, zero, or positive, respectively.  
     *     * @param o1 the first object to be compared.  
     * @param o2 the second object to be compared.  
     * @return a negative integer, zero, or a positive integer as the  
     *         first argument is less than, equal to, or greater than the     *         second.     * @throws NullPointerException if an argument is null and this  
     *         comparator does not permit null arguments     * @throws ClassCastException if the arguments' types prevent them from  
     *         being compared by this comparator.     */    int compare(T o1, T o2);  
  
    /**  
     * Indicates whether some other object is &quot;equal to&quot; this  
     * comparator.  This method must obey the general contract of     * {@link Object#equals(Object)}.  Additionally, this method can return  
     * {@code true} <i>only</i> if the specified object is also a comparator  
     * and it imposes the same ordering as this comparator.  Thus,     * {@code comp1.equals(comp2)} implies that {@code sgn(comp1.compare(o1,  
     * o2))==sgn(comp2.compare(o1, o2))} for every object reference     * {@code o1} and {@code o2}.<p>  
     *  
     * Note that it is <i>always</i> safe <i>not</i> to override  
     * {@code Object.equals(Object)}.  However, overriding this method may,  
     * in some cases, improve performance by allowing programs to determine     * that two distinct comparators impose the same order.     *     * @param   obj   the reference object with which to compare.  
     * @return  {@code true} only if the specified object is also  
     *          a comparator and it imposes the same ordering as this     *          comparator.     * @see Object#equals(Object)  
     * @see Object#hashCode()  
     */    boolean equals(Object obj);  
  
    /**  
     * Returns a comparator that imposes the reverse ordering of this     * comparator.     *     * @return a comparator that imposes the reverse ordering of this  
     *         comparator.     * @since 1.8  
     */    default Comparator<T> reversed() {  
        return Collections.reverseOrder(this);  
    }  
  
    /**  
     * Returns a lexicographic-order comparator with another comparator.     * If this {@code Comparator} considers two elements equal, i.e.  
     * {@code compare(a, b) == 0}, {@code other} is used to determine the order.  
     *     * <p>The returned comparator is serializable if the specified comparator  
     * is also serializable.     *     * @apiNote  
     * For example, to sort a collection of {@code String} based on the length  
     * and then case-insensitive natural ordering, the comparator can be     * composed using following code,     *     * <pre>{@code  
     *     Comparator<String> cmp = Comparator.comparingInt(String::length)  
     *             .thenComparing(String.CASE_INSENSITIVE_ORDER);     * }</pre>  
     *  
     * @param  other the other comparator to be used when this comparator  
     *         compares two objects that are equal.     * @return a lexicographic-order comparator composed of this and then the  
     *         other comparator     * @throws NullPointerException if the argument is null.  
     * @since 1.8  
     */    default Comparator<T> thenComparing(Comparator<? super T> other) {  
        Objects.requireNonNull(other);  
        return (Comparator<T> & Serializable) (c1, c2) -> {  
            int res = compare(c1, c2);  
            return (res != 0) ? res : other.compare(c1, c2);  
        };  
    }  
  
    /**  
     * Returns a lexicographic-order comparator with a function that     * extracts a key to be compared with the given {@code Comparator}.  
     *     * @implSpec This default implementation behaves as if {@code  
     *           thenComparing(comparing(keyExtractor, cmp))}.  
     *     * @param  <U>  the type of the sort key  
     * @param  keyExtractor the function used to extract the sort key  
     * @param  keyComparator the {@code Comparator} used to compare the sort key  
     * @return a lexicographic-order comparator composed of this comparator  
     *         and then comparing on the key extracted by the keyExtractor function     * @throws NullPointerException if either argument is null.  
     * @see #comparing(Function, Comparator)  
     * @see #thenComparing(Comparator)  
     * @since 1.8  
     */    default <U> Comparator<T> thenComparing(  
            Function<? super T, ? extends U> keyExtractor,  
            Comparator<? super U> keyComparator)  
    {  
        return thenComparing(comparing(keyExtractor, keyComparator));  
    }  
  
    /**  
     * Returns a lexicographic-order comparator with a function that     * extracts a {@code Comparable} sort key.  
     *     * @implSpec This default implementation behaves as if {@code  
     *           thenComparing(comparing(keyExtractor))}.  
     *     * @param  <U>  the type of the {@link Comparable} sort key  
     * @param  keyExtractor the function used to extract the {@link  
     *         Comparable} sort key  
     * @return a lexicographic-order comparator composed of this and then the  
     *         {@link Comparable} sort key.  
     * @throws NullPointerException if the argument is null.  
     * @see #comparing(Function)  
     * @see #thenComparing(Comparator)  
     * @since 1.8  
     */    default <U extends Comparable<? super U>> Comparator<T> thenComparing(  
            Function<? super T, ? extends U> keyExtractor)  
    {  
        return thenComparing(comparing(keyExtractor));  
    }  
  
    /**  
     * Returns a lexicographic-order comparator with a function that     * extracts an {@code int} sort key.  
     *     * @implSpec This default implementation behaves as if {@code  
     *           thenComparing(comparingInt(keyExtractor))}.  
     *     * @param  keyExtractor the function used to extract the integer sort key  
     * @return a lexicographic-order comparator composed of this and then the  
     *         {@code int} sort key  
     * @throws NullPointerException if the argument is null.  
     * @see #comparingInt(ToIntFunction)  
     * @see #thenComparing(Comparator)  
     * @since 1.8  
     */    default Comparator<T> thenComparingInt(ToIntFunction<? super T> keyExtractor) {  
        return thenComparing(comparingInt(keyExtractor));  
    }  
  
    /**  
     * Returns a lexicographic-order comparator with a function that     * extracts a {@code long} sort key.  
     *     * @implSpec This default implementation behaves as if {@code  
     *           thenComparing(comparingLong(keyExtractor))}.  
     *     * @param  keyExtractor the function used to extract the long sort key  
     * @return a lexicographic-order comparator composed of this and then the  
     *         {@code long} sort key  
     * @throws NullPointerException if the argument is null.  
     * @see #comparingLong(ToLongFunction)  
     * @see #thenComparing(Comparator)  
     * @since 1.8  
     */    default Comparator<T> thenComparingLong(ToLongFunction<? super T> keyExtractor) {  
        return thenComparing(comparingLong(keyExtractor));  
    }  
  
    /**  
     * Returns a lexicographic-order comparator with a function that     * extracts a {@code double} sort key.  
     *     * @implSpec This default implementation behaves as if {@code  
     *           thenComparing(comparingDouble(keyExtractor))}.  
     *     * @param  keyExtractor the function used to extract the double sort key  
     * @return a lexicographic-order comparator composed of this and then the  
     *         {@code double} sort key  
     * @throws NullPointerException if the argument is null.  
     * @see #comparingDouble(ToDoubleFunction)  
     * @see #thenComparing(Comparator)  
     * @since 1.8  
     */    default Comparator<T> thenComparingDouble(ToDoubleFunction<? super T> keyExtractor) {  
        return thenComparing(comparingDouble(keyExtractor));  
    }  
  
    /**  
     * Returns a comparator that imposes the reverse of the <em>natural  
     * ordering</em>.  
     *     * <p>The returned comparator is serializable and throws {@link  
     * NullPointerException} when comparing {@code null}.  
     *     * @param  <T> the {@link Comparable} type of element to be compared  
     * @return a comparator that imposes the reverse of the <i>natural  
     *         ordering</i> on {@code Comparable} objects.  
     * @see Comparable  
     * @since 1.8  
     */    public static <T extends Comparable<? super T>> Comparator<T> reverseOrder() {  
        return Collections.reverseOrder();  
    }  
  
    /**  
     * Returns a comparator that compares {@link Comparable} objects in natural  
     * order.     *     * <p>The returned comparator is serializable and throws {@link  
     * NullPointerException} when comparing {@code null}.  
     *     * @param  <T> the {@link Comparable} type of element to be compared  
     * @return a comparator that imposes the <i>natural ordering</i> on {@code  
     *         Comparable} objects.  
     * @see Comparable  
     * @since 1.8  
     */    @SuppressWarnings("unchecked")  
    public static <T extends Comparable<? super T>> Comparator<T> naturalOrder() {  
        return (Comparator<T>) Comparators.NaturalOrderComparator.INSTANCE;  
    }  
  
    /**  
     * Returns a null-friendly comparator that considers {@code null} to be  
     * less than non-null. When both are {@code null}, they are considered  
     * equal. If both are non-null, the specified {@code Comparator} is used  
     * to determine the order. If the specified comparator is {@code null},  
     * then the returned comparator considers all non-null values to be equal.     *     * <p>The returned comparator is serializable if the specified comparator  
     * is serializable.     *     * @param  <T> the type of the elements to be compared  
     * @param  comparator a {@code Comparator} for comparing non-null values  
     * @return a comparator that considers {@code null} to be less than  
     *         non-null, and compares non-null objects with the supplied     *         {@code Comparator}.  
     * @since 1.8  
     */    public static <T> Comparator<T> nullsFirst(Comparator<? super T> comparator) {  
        return new Comparators.NullComparator<>(true, comparator);  
    }  
  
    /**  
     * Returns a null-friendly comparator that considers {@code null} to be  
     * greater than non-null. When both are {@code null}, they are considered  
     * equal. If both are non-null, the specified {@code Comparator} is used  
     * to determine the order. If the specified comparator is {@code null},  
     * then the returned comparator considers all non-null values to be equal.     *     * <p>The returned comparator is serializable if the specified comparator  
     * is serializable.     *     * @param  <T> the type of the elements to be compared  
     * @param  comparator a {@code Comparator} for comparing non-null values  
     * @return a comparator that considers {@code null} to be greater than  
     *         non-null, and compares non-null objects with the supplied     *         {@code Comparator}.  
     * @since 1.8  
     */    public static <T> Comparator<T> nullsLast(Comparator<? super T> comparator) {  
        return new Comparators.NullComparator<>(false, comparator);  
    }  
  
    /**  
     * Accepts a function that extracts a sort key from a type {@code T}, and  
     * returns a {@code Comparator<T>} that compares by that sort key using  
     * the specified {@link Comparator}.  
      *     * <p>The returned comparator is serializable if the specified function  
     * and comparator are both serializable.     *     * @apiNote  
     * For example, to obtain a {@code Comparator} that compares {@code  
     * Person} objects by their last name ignoring case differences,  
     *     * <pre>{@code  
     *     Comparator<Person> cmp = Comparator.comparing(  
     *             Person::getLastName,     *             String.CASE_INSENSITIVE_ORDER);     * }</pre>  
     *  
     * @param  <T> the type of element to be compared  
     * @param  <U> the type of the sort key  
     * @param  keyExtractor the function used to extract the sort key  
     * @param  keyComparator the {@code Comparator} used to compare the sort key  
     * @return a comparator that compares by an extracted key using the  
     *         specified {@code Comparator}  
     * @throws NullPointerException if either argument is null  
     * @since 1.8  
     */    public static <T, U> Comparator<T> comparing(  
            Function<? super T, ? extends U> keyExtractor,  
            Comparator<? super U> keyComparator)  
    {  
        Objects.requireNonNull(keyExtractor);  
        Objects.requireNonNull(keyComparator);  
        return (Comparator<T> & Serializable)  
            (c1, c2) -> keyComparator.compare(keyExtractor.apply(c1),  
                                              keyExtractor.apply(c2));  
    }  
  
    /**  
     * Accepts a function that extracts a {@link java.lang.Comparable  
     * Comparable} sort key from a type {@code T}, and returns a {@code  
     * Comparator<T>} that compares by that sort key.  
     *     * <p>The returned comparator is serializable if the specified function  
     * is also serializable.     *     * @apiNote  
     * For example, to obtain a {@code Comparator} that compares {@code  
     * Person} objects by their last name,  
     *     * <pre>{@code  
     *     Comparator<Person> byLastName = Comparator.comparing(Person::getLastName);  
     * }</pre>  
     *  
     * @param  <T> the type of element to be compared  
     * @param  <U> the type of the {@code Comparable} sort key  
     * @param  keyExtractor the function used to extract the {@link  
     *         Comparable} sort key  
     * @return a comparator that compares by an extracted key  
     * @throws NullPointerException if the argument is null  
     * @since 1.8  
     */    public static <T, U extends Comparable<? super U>> Comparator<T> comparing(  
            Function<? super T, ? extends U> keyExtractor)  
    {  
        Objects.requireNonNull(keyExtractor);  
        return (Comparator<T> & Serializable)  
            (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));  
    }  
  
    /**  
     * Accepts a function that extracts an {@code int} sort key from a type  
     * {@code T}, and returns a {@code Comparator<T>} that compares by that  
     * sort key.     *     * <p>The returned comparator is serializable if the specified function  
     * is also serializable.     *     * @param  <T> the type of element to be compared  
     * @param  keyExtractor the function used to extract the integer sort key  
     * @return a comparator that compares by an extracted key  
     * @see #comparing(Function)  
     * @throws NullPointerException if the argument is null  
     * @since 1.8  
     */    public static <T> Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor) {  
        Objects.requireNonNull(keyExtractor);  
        return (Comparator<T> & Serializable)  
            (c1, c2) -> Integer.compare(keyExtractor.applyAsInt(c1), keyExtractor.applyAsInt(c2));  
    }  
  
    /**  
     * Accepts a function that extracts a {@code long} sort key from a type  
     * {@code T}, and returns a {@code Comparator<T>} that compares by that  
     * sort key.     *     * <p>The returned comparator is serializable if the specified function is  
     * also serializable.     *     * @param  <T> the type of element to be compared  
     * @param  keyExtractor the function used to extract the long sort key  
     * @return a comparator that compares by an extracted key  
     * @see #comparing(Function)  
     * @throws NullPointerException if the argument is null  
     * @since 1.8  
     */    public static <T> Comparator<T> comparingLong(ToLongFunction<? super T> keyExtractor) {  
        Objects.requireNonNull(keyExtractor);  
        return (Comparator<T> & Serializable)  
            (c1, c2) -> Long.compare(keyExtractor.applyAsLong(c1), keyExtractor.applyAsLong(c2));  
    }  
  
    /**  
     * Accepts a function that extracts a {@code double} sort key from a type  
     * {@code T}, and returns a {@code Comparator<T>} that compares by that  
     * sort key.     *     * <p>The returned comparator is serializable if the specified function  
     * is also serializable.     *     * @param  <T> the type of element to be compared  
     * @param  keyExtractor the function used to extract the double sort key  
     * @return a comparator that compares by an extracted key  
     * @see #comparing(Function)  
     * @throws NullPointerException if the argument is null  
     * @since 1.8  
     */    public static<T> Comparator<T> comparingDouble(ToDoubleFunction<? super T> keyExtractor) {  
        Objects.requireNonNull(keyExtractor);  
        return (Comparator<T> & Serializable)  
            (c1, c2) -> Double.compare(keyExtractor.applyAsDouble(c1), keyExtractor.applyAsDouble(c2));  
    }  
}
```


# 4. 方法引用

如果可以直接将方法传递到某个构造器中就方便很多了。
