# 1. 接口的定义

在 Java 程序设计语言中，**接口不是类，而是对希望符合这个接口的类的一组需求**。

所以接口是对类的一组需求，我希望这个类会符合什么样的规则。

例如 `Comparable` 接口的代码：

```java
public interface Comparable<T> {  
    /**  
     * Compares this object with the specified object for order.  Returns a     * negative integer, zero, or a positive integer as this object is less     * than, equal to, or greater than the specified object.     *     * <p>The implementor must ensure  
     * {@code sgn(x.compareTo(y)) == -sgn(y.compareTo(x))}  
     * for all {@code x} and {@code y}.  (This  
     * implies that {@code x.compareTo(y)} must throw an exception iff  
     * {@code y.compareTo(x)} throws an exception.)  
     *     * <p>The implementor must also ensure that the relation is transitive:  
     * {@code (x.compareTo(y) > 0 && y.compareTo(z) > 0)} implies  
     * {@code x.compareTo(z) > 0}.  
     *     * <p>Finally, the implementor must ensure that {@code x.compareTo(y)==0}  
     * implies that {@code sgn(x.compareTo(z)) == sgn(y.compareTo(z))}, for  
     * all {@code z}.  
     *     * <p>It is strongly recommended, but <i>not</i> strictly required that  
     * {@code (x.compareTo(y)==0) == (x.equals(y))}.  Generally speaking, any  
     * class that implements the {@code Comparable} interface and violates  
     * this condition should clearly indicate this fact.  The recommended     * language is "Note: this class has a natural ordering that is     * inconsistent with equals."     *     * <p>In the foregoing description, the notation  
     * {@code sgn(}<i>expression</i>{@code )} designates the mathematical  
     * <i>signum</i> function, which is defined to return one of {@code -1},  
     * {@code 0}, or {@code 1} according to whether the value of  
     * <i>expression</i> is negative, zero, or positive, respectively.  
     *     * @param   o the object to be compared.  
     * @return  a negative integer, zero, or a positive integer as this object  
     *          is less than, equal to, or greater than the specified object.     *     * @throws NullPointerException if the specified object is null  
     * @throws ClassCastException if the specified object's type prevents it  
     *         from being compared to this object.     */    
     public int compareTo(T o);  
}
```

可以看到，任何实现 `Comparable` 接口都需要包含 `compareTo` 方法，这个方法有一个 `Object` 参数，并且返回一个正数。也就是我们规定了一个接口，这个接口是我们对任何实现这个接口的类的一种规则，它需要实现我们希望的具有比较功能的方法。

注意：
- 接口中的所有方法都自动是 `public` 方法，因此不用显式声明关键字 `public`，不过在实现接口的时候必须将方法声明为 `public`。
- 接口绝不会有实例字段


# 2. 接口的属性

接口不是类。具体来说，不能使用 `new` 运算符实例化一个接口。

1. 可以使用 `instanceof` 检查一个对象是否实现了某个特定的接口。

```java
/**  
 * @author CoachHe  
 * @date 2022/12/6 01:42  
 **/
@SuppressWarnings("all")  
public class interfaceTest{  
    public static void main(String[] args) {  
        classA testclass = new classA();  
        System.out.println(testclass instanceof interfaceA);  
    }  
}  
interface interfaceA {}  
class classA implements interfaceA{}
```

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221207003606.png" width = "80%" />

可以看到，`classA` 实现了 `interfaceA()` 这个接口，那么其对象 `testclass instanceof interfaceA` 时判断结果为 `true` 。

2. 与接口中的方法都自动被设置为 `public` 一样，接口中的字段总是 `public static final`。

```java
/**  
 * @author CoachHe  
 * @date 2022/12/6 01:42  
 **/
@SuppressWarnings("all")  
public class interfaceTest{  
    public static void main(String[] args) {  
        classB testclassB = new classB();  
        System.out.println(testclassB.intA);  
    }  
}  
interface interfaceA {  
    String intA = "string of interface A";  
}  
interface interfaceB extends interfaceA{}  
class classB implements interfaceB{}
```

可以看到，`classB` 实现了 `interfaceB()` 这个接口，并且 `interfaceB` 继承了 `interfaceA`，并且在 `interfaceA()` 中定义了 `intA` 这个字符串，可以看到，`classB` 的对象也自动拥用了 `interfaceA` 的字符串。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221207004711.png" width = "80%" />

# 3. 接口与抽象类

## 使用抽象类的问题

使用抽象类表示通用属性存在一个严重的问题。每个类只能扩展一个类。

# 4. 静态和私有方法

目前为止，通常的做法是将静态方法放在伴随类中。在标准库里会看到承兑出现的接口和实用工具类。例如 `Path` 和 `Paths`。

这里看下 `get()` 的源码和具体使用：

```java
public final class Paths {
	public static Path get(String first, String... more) {  
	    return FileSystems.getDefault().getPath(first, more);  
	}
}

// 具体使用
Path pathA = Paths.get("");
```

可以看到，在这里 `Paths` 实用工具类的静态方法 `get()` 会生成一个 `Path` 类型的对象 `pathA`。这是之前常用的做法。

静态方法的出现解决了这个问题，在接口中内置静态方法可以直接在接口中获取对应的内置类。

在 java 11 中，`Path` 接口提供了等价的方法：

```java
pub
```

我们来看一个接口，是 `Flink` 中的水位线生成策略接口 `WatermarkStrategy`，我们只看其中的静态方法：

```java
@Public  
public interface WatermarkStrategy<T> extends TimestampAssignerSupplier<T>, WatermarkGeneratorSupplier<T> {  

    static <T> WatermarkStrategy<T> forMonotonousTimestamps() {  
        return (ctx) -> {  
            return new AscendingTimestampsWatermarks();  
        };  
    }  
  
    static <T> WatermarkStrategy<T> forBoundedOutOfOrderness(Duration maxOutOfOrderness) {  
        return (ctx) -> {  
            return new BoundedOutOfOrdernessWatermarks(maxOutOfOrderness);  
        };  
    }  
  
    static <T> WatermarkStrategy<T> forGenerator(WatermarkGeneratorSupplier<T> generatorSupplier) {  
        return generatorSupplier::createWatermarkGenerator;  
    }  
  
    static <T> WatermarkStrategy<T> noWatermarks() {  
        return (ctx) -> {  
            return new NoWatermarksGenerator();  
        };  
    }  
}
```

可以看到，在该接口中提供了 4 个静态方法，这四个静态方法分别能生成对应的水位线生成策略。相当于是 `flink` 内置了 4 个方法，用来生成对应的水位线生成策略。这四个方法的作用只是返回 `Flink` 预先写好的对应实现了 ` WatermarkStrategy ` 接口的相应功能类。



