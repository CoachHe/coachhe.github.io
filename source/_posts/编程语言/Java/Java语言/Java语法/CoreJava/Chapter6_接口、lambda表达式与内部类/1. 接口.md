# 1. 接口的定义

在 Java 程序设计语言中，**接口不是类，而是对希望符合这个接口的类的一组需求**。

所以接口是对类的一组需求，我希望这个类会符合什么样的规则。

例如 `Comparable` 接口的代码：

```java
public interface Comparable<T> {  
    /**  
     * Compares this object with the specified object for order.  Returns a     * negative integer, zero, or a positive integer as this object is less     * than, equal to, or greater than the specified object.     *     * <p>The implementor must ensure  
     * {@code sgn(x.compareTo(y)) == -sgn(y.compareTo(x))}  
     * for all {@code x} and {@code y}.  (This  
     * implies that {@code x.compareTo(y)} must throw an exception iff  
     * {@code y.compareTo(x)} throws an exception.)  
     *     * <p>The implementor must also ensure that the relation is transitive:  
     * {@code (x.compareTo(y) > 0 && y.compareTo(z) > 0)} implies  
     * {@code x.compareTo(z) > 0}.  
     *     * <p>Finally, the implementor must ensure that {@code x.compareTo(y)==0}  
     * implies that {@code sgn(x.compareTo(z)) == sgn(y.compareTo(z))}, for  
     * all {@code z}.  
     *     * <p>It is strongly recommended, but <i>not</i> strictly required that  
     * {@code (x.compareTo(y)==0) == (x.equals(y))}.  Generally speaking, any  
     * class that implements the {@code Comparable} interface and violates  
     * this condition should clearly indicate this fact.  The recommended     * language is "Note: this class has a natural ordering that is     * inconsistent with equals."     *     * <p>In the foregoing description, the notation  
     * {@code sgn(}<i>expression</i>{@code )} designates the mathematical  
     * <i>signum</i> function, which is defined to return one of {@code -1},  
     * {@code 0}, or {@code 1} according to whether the value of  
     * <i>expression</i> is negative, zero, or positive, respectively.  
     *     * @param   o the object to be compared.  
     * @return  a negative integer, zero, or a positive integer as this object  
     *          is less than, equal to, or greater than the specified object.     *     * @throws NullPointerException if the specified object is null  
     * @throws ClassCastException if the specified object's type prevents it  
     *         from being compared to this object.     */    
     public int compareTo(T o);  
}
```

可以看到，任何实现 `Comparable` 接口都需要包含 `compareTo` 方法，这个方法有一个 `Object` 参数，并且返回一个正数。也就是我们规定了一个接口，这个接口是我们对任何实现这个接口的类的一种规则，它需要实现我们希望的具有比较功能的方法。

注意：
- 接口中的所有方法都自动是 `public` 方法，因此不用显式声明关键字 `public`，不过在实现接口的时候必须将方法声明为 `public`。
- 接口绝不会有实例字段


# 2. 接口的属性

接口不是类。具体来说，不能使用 `new` 运算符实例化一个接口。

1. 可以使用 `instanceof` 检查一个对象是否实现了某个特定的接口。

```java
/**  
 * @author CoachHe  
 * @date 2022/12/6 01:42  
 **/
@SuppressWarnings("all")  
public class interfaceTest{  
    public static void main(String[] args) {  
        classA testclass = new classA();  
        System.out.println(testclass instanceof interfaceA);  
    }  
}  
interface interfaceA {}  
class classA implements interfaceA{}
```

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221207003606.png" width = "80%" />

可以看到，`classA` 实现了 `interfaceA()` 这个接口，那么其对象 `testclass instanceof interfaceA` 时判断结果为 `true` 。

2. 与接口中的方法都自动被设置为 `public` 一样，接口中的字段总是 `public static final`。

```java
/**  
 * @author CoachHe  
 * @date 2022/12/6 01:42  
 **/
@SuppressWarnings("all")  
public class interfaceTest{  
    public static void main(String[] args) {  
        classB testclassB = new classB();  
        System.out.println(testclassB.intA);  
    }  
}  
interface interfaceA {  
    String intA = "string of interface A";  
}  
interface interfaceB extends interfaceA{}  
class classB implements interfaceB{}
```

可以看到，`classB` 实现了 `interfaceB()` 这个接口，并且 `interfaceB` 继承了 `interfaceA`，并且在 `interfaceA()` 中定义了 `intA` 这个字符串，可以看到，`classB` 的对象也自动拥用了 `interfaceA` 的字符串。

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221207004711.png" width = "80%" />

# 3. 接口与抽象类

## 使用抽象类的问题

使用抽象类表示通用属性存在一个严重的问题。每个类只能扩展一个类。

# 4. 静态和私有方法

在 Java 8 中，允许在接口中增加静态方法。理论上讲，没有任何理由认为这是不合法的。只是这有违于将接口作为抽象规范的初衷。目前为止，通常的做法都是将静态方法放在伴随类中。在标准库中，你会看到成对出现的接口和实用工具类，如 `CoUection/Collections` 或 `Path/Paths`。


