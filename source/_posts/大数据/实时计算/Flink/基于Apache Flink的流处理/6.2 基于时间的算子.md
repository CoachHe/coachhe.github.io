---
title: 6.2 基于时间的算子  
date: 2022-12-04 02:13:35  
tags: []  
categories:
  - 大数据
  - 实时计算
  - Flink
  - 基于Apache Flink的流处理
---

# 时间语义

算子语义应该依赖事件实际发生时间而且应用收到事件的时间。

<img src="https://coachhe.oss-cn-shenzhen.aliyuncs.com/Scala/20210228185234.png" style="zoom:50%;" />

流式应用可以使用两个完全不同概念的时间，即处理时间和事件时间

1. 处理时间（processing time）

   处理时间是当前流处理算在所在机器上的本地时钟时间。与机器有关

2. 事件时间（event time）

   事件时间是数据流中事件实际发生的时间，它以附加在数据流中事件的时间戳为依据。

## 图解处理时间和事件时间

<img src="https://coachhe.oss-cn-shenzhen.aliyuncs.com/Scala/20210228185928.png" style="zoom:50%;" />

事件时间将处理速度和结果内容彻底解耦。我们也往往更关心事件时间。基于事件时间的操作是可预测的，其结果具有确定性。无论数据流的处理速度如何、事件到达算子的顺序怎样，基于事件时间的窗口都会生成相同的结果。

## 哪种时间语义更重要

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221204143724.png" width = "50%" />

可以看到，红色框为 Processing Time，绿色框为 Event Time，大部分时间 Event Time 更重要。

## 设置处理时间或事件时间的方法

默认状态即为处理时间，若需要使用事件时间则需要设置

### Scala 版本

```scala
package com.coachhe.apitest

import org.apache.flink.streaming.api.TimeCharacteristic
import org.apache.flink.streaming.api.environment.StreamExecutionEnvironment

object TimeWindowTest {
  def main(args: Array[String]): Unit = {
    val env: StreamExecutionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment
    // 设置事件时间
//    env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)
    // 设置处理时间
    env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime)
  }
}
```

### Java 版本

```java
public class apitest {  
    public static void main(String[] args) {  
        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();  
        // 设置为处理时间  
        env.setStreamTimeCharacteristic(TimeCharacteristic.ProcessingTime);  
    }  
}
```

# 水位线（watermark）

## 乱序数据的影响

<img src="https://coachhe.oss-cn-shenzhen.aliyuncs.com/Scala/20210301025256.png" style="zoom:33%;" />

在上图中，我们将窗口设置为 5s，那么在实际情况中，5s 的数据已经来到，此时是否应该关闭窗口？

- Flink 以 Event Time 模式处理数据流时，它会根据数据里的时间戳来处理基于时间的算子
- 由于网络、分布式等原因，会导致乱序数据的产生

因为需要引入水位线

## 水位线概念

### 水位线定义

水位线是一个**全局进度指标**，表示我们确信不会再有延迟事件到来的某个的时间点。本质上水位线提供了一个逻辑时钟，用来通知系统当前的事件时间。

当一个算子接收到时间为 T 的水位线，就可以认为不会再收到任何时间戳小于或等于 T 的事件了。水位线无论对于事件时间窗口还是处理乱序事件的算子都很关键。算子一旦收到某个水位线，就相当于接到信号：某个特定时间区间的时间戳已经到齐，可以触发窗口计算或对接收的数据进行排序了。




### 水位线特点

![](https://coachhe.oss-cn-shenzhen.aliyuncs.com/Scala/20210301031105.png)

- watermark 是一条特殊的数据记录（里面只有一类信息：当前的事件时间）
  也就是说，水位线到来之后，水位线的记录时间之前的数据开始全部不接受，窗口关闭。
- watermark 必须单调递增，以确保任务的事件时间时钟在向前推进，而不是在后退
- water 与数据时间戳相关

### 水位线的类型

#### 有序流中的水位线

1. 每条记录都插入一条水位线

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221130014608.png" width = "50%" />

   可以看到，每到来一条记录就会产生一条水位线，这种是最直观的，但是效率也很低

2. 周期性插入水位线

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221130014750.png" width = "50%" />

   可以看到，首先来的数据是 2 5 7，此时到了一个周期，会自动找到这个周期中最大值，也就是 7，产生一条水位线，然后是 9 9 9 10 11，最大值是 11，也会产生一条水位线。

#### 乱序流中的水位线

1. 判断只有数据的时间戳比当前时钟大，才能推动时间前进，这时才插入水位线

<img src=" https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/20221130015328.png" width = "50%" />

   可以看到，当水位线为9时，来了时间戳为7 9 9的数据，水位线都不产生变动，因为这个是所谓“迟到数据”，只有当时间戳为11的数据来了时，水位线才会变动。以此类推

2. 周期性插入水位线的方法

<img src="https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/image-20221130020335168.png" width = "50%" />

   和上面的类似，也是比较周期时间范围内时间戳的最大值	


#### 处理迟到数据的水位线

<img src="https://coachhe-1305181419.cos.ap-guangzhou.myqcloud.com/%E7%A8%8B%E5%BA%8F%E5%91%98/%E5%B7%A5%E5%85%B7/git/image-20221130020619684.png" width = "50%" />

可以看到，此时处理的水位线是T-2的，也就是说，当接受到数据时间为8的数据时，此时会将窗口的右半边延伸至T=6处，确保迟到数据能处理完成（但也不绝对，有可能就是延迟很久，需要做权衡）


### 水位线作用

水位线允许我们在结果的**准确性和延迟之间做出取舍**。

#### 水位线的特性

- 水位线是插入到数据流中的一个标记，可以认为是一个特殊的数据
- 水位线主要的内容是一个时间戳，用来表示当前事件时间的进展
- 水位线是基于数据的时间戳生成的
- 水位线的时间戳必须单调递增，以确保任务的事件时间时钟一直向前推进
- 水位线可以通过设置延迟，来保证正确处理乱序数据

## 水位线生成

### 水位线的生成原则

从上面我们了解到，如果存在迟到数据，那对我们水位线的生成是有影响的，那我们怎么能保证我们未来不会出现一个超级迟到数据呢？所以一种做法是，可以单独创建一个 Flink 作业来监控事件流，建立概率分布或者机器学习模型，学习事件的迟到规律。得到分布规律之后，就可以选择置信区间来确定延迟，作为水位线的生成策略了。例如，如果得到数据的迟到时间服从 μ=1，σ=1 的正态分布，那么设置水位线延迟为 3 秒，就可以保证至少 97.7%的数据可以正确处理。

如果我们希望计算结果能更加准确，那可以将水位线的延迟设置得更高一些，等待的时间越长，自然也就越不容易漏掉数据。不过这样做的代价是处理的实时性降低了，我们可能为极少数的迟到数据增加了很多不必要的延迟。

如果我们希望处理得更快、实时性更强，那么可以将水位线延迟设得低一些。这种情况下，可能很多迟到数据会在水位线之后才到达，就会导致窗口遗漏数据，计算结果不准确。对于这些 “漏网之鱼”，Flink 另外提供了窗口处理迟到数据的方法，我们会在后面介绍。当然，如果我们对准确性完全不考虑、一味地追求处理速度，可以直接使用处理时间语义，这在理论上可以得到最低的延迟。


时间戳和水位线通常都是在数据流刚刚进入流处理应用的时候分配和生成的。

生成水位线可以由以下三种方式指定：

1. 在数据源完成

   可以利用 SourceFunction 在应用读入数据流的时候分配时间戳和生成水位线。源函数会发出一条记录流。每个发出的记录都可以附加一个时间戳，水位线可以作为特殊记录在任何时间点发出。

2. 周期分配器

   用名为 AssignerWithPeriodWatermarks 的用户自定义函数，它可以用来从每条记录提取时间戳，并周期性地响应获取当前水位线的查询请求。

3. 定点分配器

   用名为 AssignerWithPunctuatedWatermarks 的用户自定义函数，它可以用于需要根据特殊输入记录产生水位线的情况。

### 周期性水位线分配器

周期性分配水位线的含义是我们会指示系统以固定的机器时间间隔来发出水位线并推动事件时间前进。

#### 举例

设置每 5 秒发出一次水位线

```scala
val env: StreamExecutionEnvironment = StreamExecutionEnvironment.getExecutionEnvironment

env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)
// 每5秒生成一次水位线
env.getConfig.setAutoWatermarkInterval(5000)
```

实际上，Flink 会每隔 5 秒调用一次 AssignerWithPeriodWatermarks 中的 getCurrentWatermark()方法。如果该方法返回值非空，且时间戳大于上一个水位线的时间戳，那么算子就会发出一个新的水位线。


## 水位线的传播

当任务接收到一个水位线时会执行以下操作：

1. 基于水位线记录的时间戳更新内部时间时钟
2. 任务的时间服务会找出所有触发时间小于更新后事件时间的计时器。对于每个到期的计时器，调用回调函数，利用它来执行计算或发出记录
3. 任务根据更新后的事件时间将水位线发出

Flink 会将数据流划分为不同的分区，并将它们交由不同的算子任务来并行执行。每个分区作为一个数据流，都会包含带有时间戳的记录以及水位线。

一个任务可能同时接受来自多个输入分区的记录和水位线，也可能需要将它们发送到多个输出分区。

### 举例

一个 4 个输入分区和 3 个输出分区的任务在接收到水位线后对分区水位线和事件时钟的更新过程。

![](https://coachhe.oss-cn-shenzhen.aliyuncs.com/Scala/20210301042945.png)

